export module engine.match;

import std;
import glm;
import stormkit.core;
import geometry;

import grid;
import potentials;
import engine.rewriterule;

using namespace stormkit;

export
struct Match {
  std::span<const RewriteRule> rules;
  glm::vec<3, u32> u;
  ioffset          r;

  double w = 1.0;

  auto area() const noexcept -> Area3U {
    return rules[r].output.area() + u;
  }

  auto conflict(const Match& other) const noexcept -> bool;
  auto match(const Grid<char>& grid) const noexcept -> bool;
  auto changes(const Grid<char>& grid) const noexcept -> std::vector<Change<char>>;

  auto backward_match(const Potentials& potentials, double p) const noexcept -> bool;
  auto backward_changes(const Potentials& potentials, double p) const noexcept -> std::vector<Change<std::tuple<char, double>>>;
  auto delta(const Grid<char>& grid, const Potentials& potentials) const noexcept -> double;
};

export template <>
struct std::formatter<Match> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for RewriteRule.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const Match& m, FmtContext& ctx) const
  {
      std::ostringstream out;
      out << std::format("{} {}", m.u, m.rules[m.r]);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};
