export module engine.rewriterule;

import std;
import glm;
import stormkit.core;
import geometry;

import grid;

using namespace stormkit;

export 
struct RewriteRule {
  static constexpr auto IGNORED_SYMBOL = char { '*' };
  
  using Unions = std::unordered_map<char, std::set<char>>;
  // using Union  = Unions::node_type;

  using Input  = std::optional<std::set<char>>;
  Grid<Input>  input;

  using Output = std::optional<char>;
  Grid<Output> output;

  std::bernoulli_distribution draw = std::bernoulli_distribution { 1.0 };
  bool original;

  using Shifts = std::unordered_multimap<char, glm::vec<3, u32>>;
  Shifts ishifts;

  RewriteRule() = delete;
  RewriteRule(Grid<Input>&& input, Grid<Output>&& output, double p = 1.0, bool original = true) noexcept;

  auto symmetries(std::string_view subgroup = "") const noexcept -> std::vector<RewriteRule>;

  inline constexpr auto operator==(const RewriteRule& other) const noexcept -> bool {
    return input    == other.input
       and output   == other.output
       and draw.p() == other.draw.p();
  };

  static inline constexpr auto parse(
    const Unions& unions,
    std::string_view input,
    std::string_view output,
    double p = 1.0
  ) noexcept -> RewriteRule {
    return {
      Grid<Input>::parse(input, [&unions](auto raw) noexcept -> Input {
        return raw == IGNORED_SYMBOL ? Input {} : Input { unions.contains(raw) ? unions.at(raw) : std::set{ raw } };
      }),
      Grid<std::optional<char>>::parse(output, [](auto raw) noexcept -> Output {
        return raw == IGNORED_SYMBOL ? Output {} : Output { raw };
      }),
      p
    };
  }

  inline constexpr auto xreflected() const noexcept -> RewriteRule {
    return RewriteRule{
      input.xreflected(),
      output.xreflected(),
      draw.p(),
      false
    };
  }

  inline constexpr auto xyrotated() const noexcept -> RewriteRule {
    return {
      input.xyrotated(),
      output.xyrotated(),
      draw.p(),
      false
    };
  }

  inline constexpr auto zyrotated() const noexcept -> RewriteRule {
    return {
      input.zyrotated(),
      output.zyrotated(),
      draw.p(),
      false
    };
  }

  inline constexpr auto area() const noexcept -> Area3U {
    return output.area();
  }

  /** Provides the relative area that this rule would update */
  inline constexpr auto forward_neighborhood() const noexcept -> Area3I {
    return area();
  }

  /** Provides the relative area from inside which this rule would update the origin */
  inline constexpr auto backward_neighborhood() const noexcept -> Area3I {
    const auto a = forward_neighborhood();
    const auto shift = glm::vec<3, i32>{1, 1, 1} - static_cast<glm::vec<3, i32>>(a.size);
    return a + shift;
  }

  constexpr auto get_ishifts(char c) const noexcept {
    auto ignored_bucket = ishifts.bucket(IGNORED_SYMBOL);
    auto shifts = std::ranges::subrange(
      ishifts.cbegin(ignored_bucket),
      ishifts.cend(ignored_bucket)
    )
      | std::views::transform(monadic::get<1>())
      | std::ranges::to<std::vector>();
    auto bucket = ishifts.bucket(c);
    shifts.append_range(std::ranges::subrange(
      ishifts.cbegin(bucket),
      ishifts.cend(bucket)
    )
      | std::views::transform(monadic::get<1>()));
    return shifts;
  }
};

export template <>
struct std::formatter<RewriteRule> {
  std::string sep = "â†’";
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      // if (*it == '#')
      // {
      //     quoted = true;
      //     ++it;
      // }
      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for RewriteRule.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const RewriteRule& r, FmtContext& ctx) const
  {
      std::ostringstream out;
      // if (quoted)
      //     out << std::quoted(s);
      // else
          out << std::format("[{}x{}]{}{}{}", r.input.extents.extent(2), r.input.extents.extent(1), r.input, sep, r.output);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};
