export module engine.rewriterule;

import std;
import glm;
import stormkit.core;
import geometry;

import grid;

using namespace stormkit;

export 
struct RewriteRule {
  using Input  = std::optional<std::set<char>>;
  using Output = std::optional<char>;
  using Unions = std::unordered_map<char, std::set<char>>;
  using Shifts = std::unordered_multimap<char, glm::vec<3, u32>>;
  using Dist   = std::bernoulli_distribution;
  
  static constexpr auto IGNORED_SYMBOL = char { '*' };
  
  Grid<Input>  input;
  Grid<Output> output;

  Dist draw;
  bool original;

  static auto parse(
    const Unions& unions,
    std::string_view input,
    std::string_view output,
    double p = 1.0
  ) noexcept -> RewriteRule;

  RewriteRule() = delete;
  RewriteRule(Grid<Input>&& input, Grid<Output>&& output, double p = 1.0, bool original = true) noexcept;

  auto operator==(const RewriteRule& other) const noexcept -> bool;

  /** Provides the relative area from inside which this rule would update the origin */
  auto backward_neighborhood() const noexcept -> Area3I;
  auto get_ishifts(char c) const noexcept -> std::vector<glm::vec<3, u32>>;

  auto xreflected() const noexcept -> RewriteRule;
  auto xyrotated() const noexcept -> RewriteRule;
  auto zyrotated() const noexcept -> RewriteRule;

  auto symmetries(std::string_view subgroup = "") const noexcept -> std::vector<RewriteRule>;

private:
  Shifts ishifts;

};

export template <>
struct std::formatter<RewriteRule> {
  std::string sep = "â†’";
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      // if (*it == '#')
      // {
      //     quoted = true;
      //     ++it;
      // }
      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for RewriteRule.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const RewriteRule& r, FmtContext& ctx) const
  {
      std::ostringstream out;
      // if (quoted)
      //     out << std::quoted(s);
      // else
          out << std::format("[{}x{}]{}{}{}", r.input.extents.extent(2), r.input.extents.extent(1), r.input, sep, r.output);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};
