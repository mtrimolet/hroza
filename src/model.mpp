export module model;

import std;
import stormkit.Core;
import pugixml;
import utils;

using namespace stormkit;

export using Palette = HashMap<char, UInt32>;

export struct Model {
  std::string_view name;
  UInt linear_size;
  UInt dimension;
  UInt MX;
  UInt MY;
  UInt MZ;

  Boolean gif;
  UInt amount;
  UInt pixelsize;
  // std::vector<Int> seeds;
  Palette palette;
  Boolean iso;
  UInt steps;
  UInt gui;

  pugi::xml_document doc;

  Model() = default;
  Model(std::string_view name, UInt linear_size, UInt dimension, UInt MX,
        UInt MY, UInt MZ, Boolean gif, UInt amount, UInt pixelsize,
        Palette palette, Boolean iso, UInt steps, UInt gui)
      : name{name}, linear_size{linear_size}, dimension{dimension}, MX{MX},
        MY{MY}, MZ{MZ}, gif{gif}, amount{amount}, pixelsize{pixelsize},
        palette{palette}, iso{iso}, steps{steps}, gui{gui} {};

  Model(Model &&other) = default;
  Model(const Model &other)
      : Model{other.name,      other.linear_size, other.dimension, other.MX,
              other.MY,        other.MZ,          other.gif,       other.amount,
              other.pixelsize, other.palette,     other.iso,       other.steps,
              other.gui} {
    doc.reset(other.doc);
  }
};

export auto parseModel(const pugi::xml_node &xmodel,
                       const Palette &default_palette)
    -> std::expected<Model, pugi::xml_parse_result> {
  auto name = xmodel.attribute("name").as_string();
  auto linearSize = xmodel.attribute("size").as_uint(-1);
  auto dimension = xmodel.attribute("d").as_uint(2);
  auto gif = xmodel.attribute("gif").as_bool(false);
  auto amount = gif ? 1 : xmodel.attribute("amount").as_uint(2);
  // const auto split_result = split(xmodel.attribute("seeds").as_string(), '');
  // auto seeds = split_result
  //   | std::views::transform(monadic::as<Int>())
  //   | std::ranges::to<std::vector>();

  auto palette = auto(default_palette);
  std::ranges::for_each(xmodel.children("color"), [&palette](const auto &c) {
    const auto symbol_str = std::string{c.attribute("symbol").as_string()};
    ensures(!std::ranges::empty(symbol_str),
            std::format("missing '{}' attribute [:{}]", "symbol", c.offset_debug()));
    // use .emplace if new values
    palette.at(symbol_str[0]) =
        (255u << 24u) + fromBase<UInt32>(c.attribute("value").as_string(), 16);
  });

  auto model = Model{
    name,
    linearSize,
    dimension,
    xmodel.attribute("length").as_uint(linearSize),
    xmodel.attribute("width").as_uint(linearSize),
    xmodel.attribute("height").as_uint(dimension == 2 ? 1 : linearSize),
    gif,
    amount,
    xmodel.attribute("pixelsize").as_uint(4),
    std::move(palette),
    xmodel.attribute("iso").as_bool(false),
    xmodel.attribute("steps").as_uint(gif ? 1000 : 50000),
    xmodel.attribute("gui").as_uint(0)};

  if (const auto load_result =
          model.doc.load_file(std::data(std::format("models/{}.xml", name)));
      !load_result)
    return std::unexpected{load_result};

  return std::move(model);
}
