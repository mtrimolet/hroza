export module grid;

import std;
import glm;
import stormkit.Core;
import pugixml;
import xml_tree_walker;
import rule;
import utils;

using namespace std::literals;
using namespace stormkit;

export struct Grid {
public:
  using Symbol = char;
  // 0 <= {s : State} < size(symbols)
  using State = UInt;
  // size({w : Wave}) == size(state)
  using Wave = std::vector<Boolean>;

  using Size = Rule::Size;
  Size size;

  // size(state) == size[0] * size[1] * size[2]
  std::vector<State> states;
  // size(mask) == size(state)
  std::vector<Boolean> mask;

  std::vector<Symbol> symbols;
  // size(values) == size(symbols)
  std::unordered_map<Symbol, State> values;
  // size(waves) == size(symbols) + 1
  std::unordered_map<Symbol, Wave> waves;

  std::string_view folder;

  Grid() noexcept = default;
  Grid(Size &&size, std::vector<Symbol>&& symbols, std::string_view folder, std::string_view transparent) noexcept;
  
  Grid(const Grid&) noexcept = default;
  auto operator=(const Grid&) noexcept -> Grid& = default;
  Grid(Grid&&) noexcept = default;
  auto operator=(Grid&&) noexcept -> Grid& = default;

  auto at(const math::Vector3I&) noexcept -> State&;
  auto at(const math::Vector3I&) const noexcept -> const State&;
  // auto at(math::Vector3I::value_type, math::Vector3I::value_type, math::Vector3I::value_type) noexcept -> State&;
  // auto at(math::Vector3I::value_type, math::Vector3I::value_type, math::Vector3I::value_type) const noexcept -> const State&;

  auto clear() noexcept -> void;
  auto wave(std::string_view _values) const noexcept -> Wave;

  auto matches(const Rule& rule, const math::Vector3I& x) const noexcept -> Boolean;

  auto center() const noexcept -> decltype(auto);

private:
  Wave transparent;
  // size(statebuffer) == size(state)
  // std::vector<State> statebuffer;
};

Grid::Grid(Size &&size, std::vector<Symbol>&& symbols, std::string_view folder, std::string_view _transparent) noexcept
    : size{size}, states(size[0] * size[1] * size[2]),
      // statebuffer(size[0] * size[1] * size[2]),
      mask(size[0] * size[1] * size[2]),
      symbols{symbols},
      // none_wave{std::views::repeat(Boolean{false})
      //   | std::views::take(std::ranges::size(symbols))
      //   | std::ranges::to<std::vector>()},
      values{std::views::zip(symbols, std::views::iota(0u))
        | std::ranges::to<std::unordered_map>()},
      waves{symbols
        | std::views::transform([this](auto&& symbol) {
            return std::make_pair(symbol, wave(std::string{symbol}));
          })
        | std::ranges::to<std::unordered_map>()},
      folder{folder},
      transparent{wave(_transparent)} {

  auto any_wave = std::views::repeat(Boolean{true})
      | std::views::take(std::ranges::size(symbols))
      | std::ranges::to<std::vector>();

  waves.insert({'*', std::move(any_wave)});
}

export auto parseGrid(const pugi::xml_node &xelem, Grid::Size&& size) -> Grid {
  const auto values = std::string{xelem.attribute("values").as_string()};
  ensures(!std::empty(values), std::format("no values specified [:{}]", xelem.offset_debug()));

  auto symbols = std::vector(std::ranges::begin(values), std::ranges::end(values));
  ensures(std::ranges::size(symbols) == std::ranges::size(std::set(std::ranges::begin(symbols), std::ranges::end(symbols))),
          std::format("found {} duplicated values [:{}]",
            std::ranges::size(values) - std::ranges::size(symbols),
            xelem.offset_debug()));

  auto grid = Grid{
    std::move(size),
    std::move(symbols),
    xelem.attribute("folder").as_string(),
    xelem.attribute("transparent").as_string(),
  };

  // constexpr auto is_union = [](auto &&elem) {
  //   return elem.name() == "union"sv;
  // };

  // for (auto &&xunion : XMLDepthWalker{xelem.root()}) {
    // auto symbol = std::string{xunion.attribute("symbol").as_string()}.at(0);
    // ensures(!waves.contains(symbol), std::format("repeating union {}", symbol));

    // const auto w = wave(xunion.attribute("values").as_string());
    // waves.insert({symbol, w});
  // }

  return std::move(grid);
}

auto Grid::at(const math::Vector3I& u) noexcept -> Grid::State& {
  return states.at(u.x + u.y * get<0>(size) + u.z * get<0>(size) * get<1>(size));
}

auto Grid::at(const math::Vector3I& u) const noexcept -> const Grid::State& {
  return states.at(u.x + u.y * get<0>(size) + u.z * get<0>(size) * get<1>(size));
}

auto Grid::clear() noexcept -> void {
  for (auto &&component : states) component = 0;
}

auto Grid::wave(std::string_view _values) const noexcept -> Wave {
  ensures(!std::ranges::empty(values), "cannot call 'Grid::wave' before Grid initialization");
  auto w = std::views::repeat(Boolean{false})
        | std::views::take(std::ranges::size(symbols))
        | std::ranges::to<std::vector>();
  for (auto &&value : _values) w.at(values.at(value)) = true;
  return std::move(w);
}

auto Grid::matches(const Rule& rule, const math::Vector3I& u) const noexcept -> Boolean {
  const auto s = get<0>(rule.input_size) * get<1>(rule.input_size) * get<2>(rule.input_size);
  return std::ranges::none_of(
    std::views::zip(rule.input, std::views::iota(0)),
    [this, &u, &s] (const auto& v) {
      const auto& [input_part, i] = v;
      const auto dx = i;
      const auto dy = dx / get<0>(size);
      const auto dz = dy / get<1>(size);
      const auto du = math::Vector3I{
        dx % get<0>(size),
        dy % get<1>(size),
        dz % get<2>(size)
      };

      auto here = std::views::repeat(Boolean{false})
          | std::views::take(std::ranges::size(symbols))
          | std::ranges::to<std::vector>();

      here.at(at(u + du)) = true;

      return std::ranges::any_of(std::views::zip(input_part, here), [](const auto& v){
        const auto& [a, b] = v;
        return a and b;
      });
  });
}

auto Grid::center() const noexcept -> decltype(auto) {
  return ::center(size);
}