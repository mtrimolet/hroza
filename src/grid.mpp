export module grid;

import std;
import glm;
import stormkit.Core;

using namespace stormkit;

export {
template <class Value = char>
using Grid = std::vector<Value>;

inline constexpr auto toIndex(const math::Vector3U& u, const math::Vector3U& size) noexcept -> decltype(auto) {
  return u.x * 1
       + u.y * size.x
       + u.z * size.x * size.y;
}

inline constexpr auto fromIndex(UInt u, const math::Vector3U& size) noexcept -> decltype(auto) {
  return math::Vector3U{
    (u / (1)) % size.x,
    (u / (size.x)) % size.y,
    (u / (size.x * size.y)) % size.z,
  };
}

inline constexpr auto inBounds(const math::Vector3U& u, const math::Vector3U& highest) -> decltype(auto) {
  return u.x <= highest.x
      && u.y <= highest.y
      && u.z <= highest.z;
}

// struct Grid {
//   using Position = UInt;
//   std::array<UInt, 1> size;
//   std::vector<Value> values;

//   inline constexpr auto operator==(const Grid& other) const noexcept -> bool {
//     return values == other.values;
//   }

//   inline constexpr auto toIndex(const Position& u) const noexcept -> decltype(auto) {
//     return u % std::ranges::size(values);
//   }

//   inline constexpr auto fromIndex(UInt u) const noexcept -> decltype(auto) {
//     return u % std::ranges::size(values);
//   }

//   inline constexpr auto operator[](const Position& u) noexcept -> decltype(auto) {
//     return values[toIndex(u)];
//   }

//   inline constexpr auto at(const Position& u) const noexcept -> decltype(auto) {
//     return values.at(toIndex(u));
//   }

//   inline constexpr auto cbegin() const noexcept -> decltype(auto) {
//     return std::ranges::cbegin(values);
//   }

//   inline constexpr auto cend() const noexcept -> decltype(auto) {
//     return std::ranges::cend(values);
//   }

//   inline constexpr auto begin() const noexcept -> decltype(auto) {
//     return std::ranges::begin(values);
//   }

//   inline constexpr auto end() const noexcept -> decltype(auto) {
//     return std::ranges::end(values);
//   }
// };
}