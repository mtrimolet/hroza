export module grid;

import std;
import glm;
import stormkit.Core;

using namespace stormkit;

export {

inline constexpr auto toIndex(const math::Vector3U& u, const math::Vector3U& size) noexcept -> decltype(auto) {
  return u.x * 1
       + u.y * size.x
       + u.z * size.x * size.y;
}

inline constexpr auto fromIndex(UInt u, const math::Vector3U& size) noexcept -> decltype(auto) {
  return math::Vector3U{
    (u / (1)) % size.x,
    (u / (size.x)) % size.y,
    (u / (size.x * size.y)) % size.z,
  };
}

inline constexpr auto inBounds(const math::Vector3U& u, const math::Vector3U& highest) -> decltype(auto) {
  return u.x <= highest.x
      && u.y <= highest.y
      && u.z <= highest.z;
}

template <class T>
struct Grid {
  math::Vector3U size;
  std::vector<T> values;

  Grid(math::Vector3U _size, std::vector<T> _values) noexcept : size{_size}, values{_values} {}
  Grid(math::Vector3U _size, T v) noexcept : size{_size}, values{std::views::repeat(v, size.z * size.y * size.x) | std::ranges::to<std::vector>()} {}

  Grid(std::initializer_list<std::initializer_list<std::initializer_list<T>>> _values) noexcept
    : size{
        std::empty(_values) or std::empty(std::ranges::begin(_values)[0]) ? 0
          : std::ranges::size(std::ranges::begin(std::ranges::begin(_values)[0])[0]),
        std::empty(_values) ? 0 : std::ranges::size(std::ranges::begin(_values)[0]),
        std::ranges::size(_values)},
    values{_values | std::views::join | std::views::join | std::ranges::to<std::vector>()} {}

  inline constexpr auto operator==(const Grid<T>& other) const noexcept -> bool = default;

  inline constexpr auto at(const math::Vector3U& u) const noexcept -> decltype(auto) {
    return values.at(toIndex(u, size));
  }

  inline constexpr auto operator[](const math::Vector3U& u) noexcept -> decltype(auto) {
    return values[toIndex(u, size)];
  }
};

template <class T>
struct Change {
  math::Vector3U u;
  T value;
};

template <class T>
inline constexpr auto apply(Grid<T>& grid, const Change<T>& change) noexcept -> decltype(auto) {
  grid[change.u] = change.value;
}

template <class T>
inline constexpr auto xreflected(const Grid<T>& grid) noexcept -> decltype(auto) {
  auto size = auto{grid.size};
  return Grid<T>{
    size,
    std::views::iota(0u, size.z * size.y * size.x)
      | std::views::transform([&size, &grid](auto i) noexcept {
          const auto u = fromIndex(i, size);
          return grid.at({
            size.x - u.x - 1u,
            u.y, u.z
          });
      })
      | std::ranges::to<std::vector>()
  };
}

template <class T>
inline constexpr auto xyrotated(const Grid<T>& grid) noexcept -> decltype(auto) {
  auto size = math::Vector3U{
    grid.size.y,
    grid.size.x,
    grid.size.z,
  };
  return Grid<T>{
    size,
    std::views::iota(0u, size.z * size.y * size.x)
      | std::views::transform([&size, &grid](auto i) noexcept {
          const auto u = fromIndex(i, size);
          return grid.at({
            u.y,
            size.x - u.x - 1,
            u.z
          });
      })
      | std::ranges::to<std::vector>()
  };
}

template <class T>
inline constexpr auto zyrotated(const Grid<T>& grid) noexcept -> decltype(auto) {
  auto size = math::Vector3U{
    grid.size.x,
    grid.size.z,
    grid.size.y,
  };
  return Grid<T>{
    size,
    std::views::iota(0u, size.z * size.y * size.x)
      | std::views::transform([&size, &grid](auto i) noexcept {
          constexpr auto u = fromIndex(i, size);
          return grid.at({
            u.x,
            size.z - u.z - 1,
            u.y,
          });
      })
      | std::ranges::to<std::vector>()
  };
}
}