export module grid;

import std;
import glm;
import stormkit.Core;
import pugixml;
import xml_tree_walker;
import rule;
import utils;

using namespace std::literals;
using namespace stormkit;

export struct Grid {
public:
  using Symbol = char;
  // 0 <= {s : State} < size(symbols)
  using State = UInt;
  // size({w : Wave}) == size(state)
  using Wave = std::vector<Boolean>;

  using Size = Rule::Size;
  Size size;

  // size(state) == size[0] * size[1] * size[2]
  std::vector<State> states;
  // size(mask) == size(state)
  std::vector<Boolean> mask;

  std::vector<Symbol> symbols;
  // size(values) == size(symbols)
  std::unordered_map<Symbol, State> values;
  // size(waves) >= size(symbols) + 1
  std::unordered_map<Symbol, Wave> waves;

  std::string_view folder;

  Grid() noexcept = default;
  Grid(Size &&size, std::vector<Symbol>&& symbols, std::string_view folder, std::string_view transparent) noexcept;
  
  Grid(const Grid&) noexcept = default;
  auto operator=(const Grid&) noexcept -> Grid& = default;
  Grid(Grid&&) noexcept = default;
  auto operator=(Grid&&) noexcept -> Grid& = default;

  auto at(const math::Vector3I&) noexcept -> State&;
  auto at(const math::Vector3I&) const noexcept -> const State&;

  auto clear() noexcept -> void;
  auto wave(std::string_view _values) const noexcept -> Wave;

  auto matches(const Rule& rule, const math::Vector3I& x) const noexcept -> Boolean;

  auto center() const noexcept -> decltype(auto);

private:
  Wave transparent;
  // size(statebuffer) == size(state)
  // std::vector<State> statebuffer;
};

Grid::Grid(Size &&_size, std::vector<Symbol>&& _symbols, std::string_view folder, std::string_view _transparent) noexcept
    : size{std::move(_size)}, states(std::get<0>(size) * std::get<1>(size) * std::get<2>(size)),
      // statebuffer(size[0] * size[1] * size[2]),
      mask(std::ranges::size(states)),
      symbols{std::move(_symbols)},
      values{std::views::zip(symbols, std::views::iota(0u))
        | std::ranges::to<std::unordered_map>()},
      waves{symbols
        | std::views::transform([this](auto&& symbol) {
            return std::make_pair(symbol, wave(std::string{symbol}));
          })
        | std::ranges::to<std::unordered_map>()},
      folder{folder},
      transparent{wave(_transparent)} {}

export auto parseGrid(const pugi::xml_node &xelem, Grid::Size&& size) -> Grid {
  const auto values = std::string{xelem.attribute("values").as_string()};
  ensures(!std::empty(values), std::format("missing '{}' attribute in '{}' node [:{}]", "values", "grid", xelem.offset_debug()));

  auto symbols = std::vector(std::ranges::begin(values), std::ranges::end(values));
  const auto symbolset = std::set(std::ranges::begin(symbols), std::ranges::end(symbols));
  ensures(std::ranges::size(symbols) == std::ranges::size(symbolset),
          std::format("duplicated symbols in '{}' attribute of '{}' node [:{}]", "values", "grid", xelem.offset_debug()));

  auto grid = Grid{
    std::move(size),
    std::move(symbols),
    xelem.attribute("folder").as_string(),
    xelem.attribute("transparent").as_string(),
  };

  auto w = std::views::repeat(Boolean{true}, std::ranges::size(symbols))
      | std::ranges::to<std::vector>();

  grid.waves.insert({'*', std::move(w)});

  for (auto&& xunion : XMLDepthWalker{xelem}) {
    if (xunion.name() != "union"sv) continue;

    const auto symbol_str = std::string{xunion.attribute("symbol").as_string()};
    ensures(!std::ranges::empty(symbol_str),
            std::format("missing '{}' attribute in '{}' node [:{}]", "symbol", "union", xunion.offset_debug()));
    ensures(std::ranges::size(symbol_str) == 1,
            std::format("only one character allowed for '{}' attribute of '{}' node [:{}]", "symbol", "union", xunion.offset_debug()));
    
    const auto symbol = symbol_str[0];
    ensures(!grid.waves.contains(symbol),
            std::format("conflicting symbol '{}' in '{}' attribute of '{}' node [:{}]", symbol, "symbol", "union", xunion.offset_debug()));

    const auto w = grid.wave(xunion.attribute("values").as_string());
    grid.waves.insert({symbol, w});
  }

  return std::move(grid);
}

auto Grid::at(const math::Vector3I& u) noexcept -> Grid::State& {
  return states.at(u.x + u.y * get<2>(size) + u.z * get<2>(size) * get<1>(size));
}

auto Grid::at(const math::Vector3I& u) const noexcept -> const Grid::State& {
  return states.at(u.x + u.y * get<2>(size) + u.z * get<2>(size) * get<1>(size));
}

auto Grid::clear() noexcept -> void {
  for (auto &&component : states) component = 0;
}

auto Grid::wave(std::string_view _values) const noexcept -> Wave {
  ensures(!std::ranges::empty(values), "cannot call 'Grid::wave' before Grid initialization");
  return symbols
      | std::views::transform([&_values](auto sym){ return Boolean{_values.contains(sym)}; })
      | std::ranges::to<std::vector>();
}

auto Grid::matches(const Rule& rule, const math::Vector3I& u) const noexcept -> Boolean {
  return std::ranges::all_of(
    std::views::zip(rule.input, std::views::iota(0u)),
    [&](const auto &wav) {
      const auto& [input_wave, i] = wav;
      const auto du = math::Vector3I{
        i % std::get<2>(rule.input_size),
        (i / std::get<2>(rule.input_size)) % std::get<1>(rule.input_size),
        (i / (std::get<2>(rule.input_size) * std::get<1>(rule.input_size))) % std::get<0>(rule.input_size),
      };

      return input_wave.at(at(u + du));
    }
  );
}

auto Grid::center() const noexcept -> decltype(auto) { return ::center(size); }