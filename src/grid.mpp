export module grid;

import std;
import glm;
import stormkit.Core;
import utils;

using namespace stormkit;

export {

inline constexpr auto toIndex(const math::Vector3U& u, const math::Vector3U& extents) noexcept -> decltype(auto) {
  return u.x * 1
       + u.y * extents.x
       + u.z * extents.x * extents.y;
}

inline constexpr auto fromIndex(UInt u, const math::Vector3U& extents) noexcept -> decltype(auto) {
  return math::Vector3U{
    (u / (1)) % extents.x,
    (u / (extents.x)) % extents.y,
    (u / (extents.x * extents.y)) % extents.z,
  };
}

inline constexpr auto locations(const math::Vector3U& extents) noexcept -> decltype(auto) {
  return std::views::iota(0u, extents.z * extents.y * extents.x)
    | std::views::transform(bindBack(fromIndex, extents));
}

inline constexpr auto inBounds(const math::Vector3U& u, const math::Vector3U& extents) -> decltype(auto) {
  return u.x <= extents.x
      && u.y <= extents.y
      && u.z <= extents.z;
}

template <class R, class T>
concept container_compatible_range = 
  std::ranges::input_range<R>
  and std::convertible_to<std::ranges::range_reference_t<R>, T>;

template <class T>
struct Grid {
  math::Vector3U extents;
  std::vector<T> values;

  template<container_compatible_range<T> R>
  Grid(std::from_range_t, R&& _values, math::Vector3U _extents) noexcept : extents{_extents}, values{std::from_range, _values} {}
  Grid(math::Vector3U _extents, T v) noexcept : Grid{std::from_range, std::views::repeat(v, _extents.z * _extents.y * _extents.x), _extents} {}

  inline constexpr auto operator==(const Grid<T>& other) const noexcept -> bool = default;

  inline constexpr auto at(const math::Vector3U& u) const noexcept -> decltype(auto) {
    return values.at(toIndex(u, extents));
  }

  inline constexpr auto operator[](const math::Vector3U& u) noexcept -> decltype(auto) {
    return values[toIndex(u, extents)];
  }

  inline constexpr auto begin() const noexcept -> decltype(auto) {
    return std::ranges::begin(values);
  }
  inline constexpr auto cbegin() const noexcept -> decltype(auto) {
    return std::ranges::cbegin(values);
  }

  inline constexpr auto end() const noexcept -> decltype(auto) {
    return std::ranges::end(values);
  }
  inline constexpr auto cend() const noexcept -> decltype(auto) {
    return std::ranges::cend(values);
  }

  static inline constexpr auto parse(T Zsep, T Ysep, std::basic_string_view<T> str) noexcept -> decltype(auto) {
    auto _values = str
      | std::views::split(Zsep)
      | std::views::transform([Ysep](auto&& square){ 
          return square
            | std::views::split(Ysep)
            | std::views::transform([](auto&& line){
                return line
                  | std::ranges::to<std::vector>();
              })
            | std::ranges::to<std::vector>(); 
        })
      | std::ranges::to<std::vector>();
    auto _extents = math::Vector3U{
      std::ranges::empty(_values) or std::ranges::empty(_values[0]) ? 0u
        : std::ranges::size(_values[0][0]),
      std::ranges::empty(_values) ? 0u
        : std::ranges::size(_values[0]),
      std::ranges::size(_values)
    };

    return _values
      | std::views::join
      | std::views::join
      | std::ranges::to<Grid<T>>(_extents);
  }
};

template <class T>
struct Change {
  math::Vector3U u;
  T value;
};

template <class T>
struct TracedGrid : Grid<T> {
  std::vector<Change<T>> history;

  TracedGrid(math::Vector3U _extents, T v) noexcept
    : Grid<T>{_extents, v}, history{} {}

  inline constexpr auto apply(const Change<T>& change) noexcept -> decltype(auto) {
    history.push_back(change);
    Grid<T>::operator[](change.u) = change.value;
  }
};

template <class T>
inline constexpr auto xreflected(const Grid<T>& grid) noexcept -> decltype(auto) {
  auto extents = auto{grid.extents};
  return locations(extents)
    | std::views::transform([&extents, &grid](auto u) noexcept {
        return grid.at({ extents.x - u.x - 1u, u.y, u.z });
    })
    | std::ranges::to<Grid<T>>(extents);
}

template <class T>
inline constexpr auto xyrotated(const Grid<T>& grid) noexcept -> decltype(auto) {
  auto extents = math::Vector3U{
    grid.extents.y,
    grid.extents.x,
    grid.extents.z,
  };
  return locations(extents)
    | std::views::transform([&extents, &grid](auto u) noexcept {
        return grid.at({ u.y, extents.x - u.x - 1, u.z });
    })
    | std::ranges::to<Grid<T>>(extents);
}

template <class T>
inline constexpr auto zyrotated(const Grid<T>& grid) noexcept -> decltype(auto) {
  auto extents = math::Vector3U{
    grid.extents.x,
    grid.extents.z,
    grid.extents.y,
  };
  return locations(extents)
    | std::views::transform([&extents, &grid](auto u) noexcept {
        return grid.at({ u.x, extents.z - u.z - 1, u.y });
    })
    | std::ranges::to<Grid<T>>(extents);
}
}