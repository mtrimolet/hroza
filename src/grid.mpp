export module grid;

import std;
import glm;
import stormkit.Core;
import pugixml;
import xml_tree_walker;
import rule;
import utils;

using namespace std::literals;
using namespace stormkit;

export struct Grid {
public:
  using Symbol = char;
  // 0 <= {s : State} < size(symbols)
  using State = UInt;
  // size({w : Wave}) == size(state)
  using Wave = std::vector<Boolean>;

  using Size = Rule::Size;
  Size size;

  // size(state) == size[0] * size[1] * size[2]
  std::vector<State> states;
  // size(mask) == size(state)
  std::vector<Boolean> mask;

  std::vector<Symbol> symbols;
  // size(values) == size(symbols)
  std::unordered_map<Symbol, State> values;
  // size(waves) == size(symbols) + 1
  std::unordered_map<Symbol, Wave> waves;

  std::string_view folder;

  Grid() noexcept = default;
  Grid(Size &&size, std::vector<Symbol>&& symbols, std::string_view folder, std::string_view transparent) noexcept;
  
  Grid(const Grid&) noexcept = default;
  auto operator=(const Grid&) noexcept -> Grid& = default;
  Grid(Grid&&) noexcept = default;
  auto operator=(Grid&&) noexcept -> Grid& = default;

  auto at(const math::Vector3I&) noexcept -> State&;
  auto at(const math::Vector3I&) const noexcept -> const State&;

  auto clear() noexcept -> void;
  auto wave(std::string_view _values) const noexcept -> Wave;
  auto none_wave() const noexcept -> Wave;
  auto any_wave() const noexcept -> Wave;

  auto matches(const Rule& rule, const math::Vector3I& x) const noexcept -> Boolean;

  auto center() const noexcept -> decltype(auto);

private:
  Wave transparent;
  // size(statebuffer) == size(state)
  // std::vector<State> statebuffer;
};

Grid::Grid(Size &&size, std::vector<Symbol>&& symbols, std::string_view folder, std::string_view _transparent) noexcept
    : size{size}, states(size[0] * size[1] * size[2]),
      // statebuffer(size[0] * size[1] * size[2]),
      mask(size[0] * size[1] * size[2]),
      symbols{symbols},
      values{std::views::zip(symbols, std::views::iota(0u))
        | std::ranges::to<std::unordered_map>()},
      waves{symbols
        | std::views::transform([this](auto&& symbol) {
            return std::make_pair(symbol, wave(std::string{symbol}));
          })
        | std::ranges::to<std::unordered_map>()},
      folder{folder},
      transparent{wave(_transparent)} {}

auto Grid::none_wave() const noexcept -> Grid::Wave {
  return std::views::repeat(Boolean{false})
      | std::views::take(std::ranges::size(symbols))
      | std::ranges::to<std::vector>();
}
auto Grid::any_wave() const noexcept -> Grid::Wave {
  return std::views::repeat(Boolean{true})
      | std::views::take(std::ranges::size(symbols))
      | std::ranges::to<std::vector>();
}

export auto parseGrid(const pugi::xml_node &xelem, Grid::Size&& size) -> Grid {
  const auto values = std::string{xelem.attribute("values").as_string()};
  ensures(!std::empty(values), std::format("missing '{}' attribute in '{}' node [:{}]", "values", "grid", xelem.offset_debug()));

  auto symbols = std::vector(std::ranges::begin(values), std::ranges::end(values));
  const auto symbolset = std::set(std::ranges::begin(symbols), std::ranges::end(symbols));
  ensures(std::ranges::size(symbols) == std::ranges::size(symbolset),
          std::format("duplicated symbols in '{}' attribute of '{}' node [:{}]", "values", "grid", xelem.offset_debug()));

  auto grid = Grid{
    std::move(size),
    std::move(symbols),
    xelem.attribute("folder").as_string(),
    xelem.attribute("transparent").as_string(),
  };

  grid.waves.insert({'*', grid.any_wave()});

  for (auto&& xunion : XMLDepthWalker{xelem}) {
    if (xunion.name() != "union"sv) continue;

    const auto symbol_str = std::string{xunion.attribute("symbol").as_string()};
    ensures(!std::ranges::empty(symbol_str),
            std::format("missing '{}' attribute in '{}' node [:{}]", "symbol", "union", xunion.offset_debug()));
    ensures(std::ranges::size(symbol_str) == 1,
            std::format("only one character allowed for '{}' attribute of '{}' node [:{}]", "symbol", "union", xunion.offset_debug()));
    
    const auto symbol = symbol_str[0];
    ensures(!grid.waves.contains(symbol),
            std::format("conflicting symbol '{}' in '{}' attribute of '{}' node [:{}]", symbol, "symbol", "union", xunion.offset_debug()));

    const auto w = grid.wave(xunion.attribute("values").as_string());
    grid.waves.insert({symbol, w});
  }

  return std::move(grid);
}

auto Grid::at(const math::Vector3I& u) noexcept -> Grid::State& {
  return states.at(u.x + u.y * get<0>(size) + u.z * get<0>(size) * get<1>(size));
}

auto Grid::at(const math::Vector3I& u) const noexcept -> const Grid::State& {
  return states.at(u.x + u.y * get<0>(size) + u.z * get<0>(size) * get<1>(size));
}

auto Grid::clear() noexcept -> void {
  for (auto &&component : states) component = 0;
}

auto Grid::wave(std::string_view _values) const noexcept -> Wave {
  ensures(!std::ranges::empty(values), "cannot call 'Grid::wave' before Grid initialization");
  auto w = none_wave();
  for (auto &&value : _values) w.at(values.at(value)) = true;
  return std::move(w);
}

auto Grid::matches(const Rule& rule, const math::Vector3I& u) const noexcept -> Boolean {
  const auto s = get<0>(rule.input_size) * get<1>(rule.input_size) * get<2>(rule.input_size);
  return std::ranges::all_of(
    std::views::zip(rule.input, std::views::iota(0)),
    [this, &u, &s](const auto& v) {
      const auto& [input_square, dz] = v;
      return std::ranges::all_of(
        std::views::zip(input_square, std::views::iota(0)),
        [this, &u, &s, &dz](const auto &v) {
          const auto& [input_line, dy] = v;
          return std::ranges::all_of(
            std::views::zip(input_line, std::views::iota(0)),
            [this, &u, &s, &dz, &dy](const auto &v) {
              const auto& [input_wave, dx] = v;

              const auto du = math::Vector3I{dx, dy, dz};
              const auto w = wave(std::string{symbols.at(at(u + du))});

              return std::ranges::any_of(std::views::zip(input_wave, w), [](const auto& v) {
                const auto& [a, b] = v;
                return a and b;
              });
            });
        });
    });
}

auto Grid::center() const noexcept -> decltype(auto) { return ::center(size); }