export module examples;

import std;
import stormkit.Core;
import utils;

import pugixml;

import rule;
import rulenode;
import node;

using namespace stormkit;
using namespace std::literals;
using symbol = char;

export {
namespace examples {
inline constexpr auto parseXmlRule(
  const pugi::xml_node& xnode,
  std::unordered_map<symbol, std::unordered_set<symbol>> unions = {}
) noexcept -> decltype(auto) {
  return Rule::parse(
    unions,
    xnode.attribute("in").as_string(),
    xnode.attribute("out").as_string(),
    xnode.attribute("p").as_double(1.0),
  );
}

inline constexpr auto parseXmlRules(
  const pugi::xml_node& xnode,
  std::unordered_map<symbol, std::unordered_set<symbol>> unions = {},
  std::string_view symmetry = ""
) noexcept -> decltype(auto) {
  auto xrules = xnode.children("rule") | std::ranges::to<std::vector>();
  if (std::ranges::empty(xrules)) xrules.push_back(xnode);
  return xrules
     | std::views::transform(bindBack(parseXmlRule, unions))
     | std::views::transform(bindBack(symmetries, symmetry))
     | std::views::join
     | std::ranges::to<std::vector>();
}

inline constexpr auto parseXmlRuleNode(
  const pugi::xml_node& xnode,
  std::unordered_map<symbol, std::unordered_set<symbol>> unions = {},
  std::string_view symmetry = ""
) noexcept -> Action {
  const auto tag = xnode.name();
  if (tag == "one"s) {
    return One{parseXmlRules(xnode, unions, symmetry)};
  }
  else if (tag == "prl"s) {
    return Prl{parseXmlRules(xnode, unions, symmetry)};
  }
  else if (tag == "all"s) {
    return All{parseXmlRules(xnode, unions, symmetry)};
  }

  ensures(false, std::format("unknown tag {}", tag));
  std::unreachable();
}

inline constexpr auto parseXmlNode(
  const pugi::xml_node& xnode,
  std::unordered_map<symbol, std::unordered_set<symbol>> unions = {},
  std::string_view symmetry = ""
) noexcept -> Node {
  symmetry = xnode.attribute("symmetry").as_string(std::data(symmetry));
  unions.insert_range(xnode.children("union") | std::views::transform([](const pugi::xml_node& xnode) noexcept {
    return std::make_pair(
      xnode.attribute("symbol").as_string()[0],
      std::string{xnode.attribute("values").as_string()} | std::ranges::to<std::unordered_set>()
    );
  }));
  
  const auto tag = xnode.name();
  if (tag == "sequence"s) {
    return Sequence{
      xnode.children()
        | std::views::filter([](const pugi::xml_node& c) noexcept { return c.name() != "union"s; })
        | std::views::transform(bindBack(parseXmlNode, unions, symmetry))
        | std::ranges::to<std::vector>()
    };
  }
  else if (tag == "markov"s) {
    return Markov{
      xnode.children()
        | std::views::filter([](const pugi::xml_node& c) noexcept { return c.name() != "union"s; })
        | std::views::transform(bindBack(parseXmlNode, unions, symmetry))
        | std::ranges::to<std::vector>()
    };
  }
  else if (tag == "one"s
        or tag == "prl"s
        or tag == "all"s) {
    const auto steps = xnode.attribute("steps").as_uint(0);
    if (steps == 0)
      return NoLimit{parseXmlRuleNode(xnode, unions, symmetry)};
    else
      return Limit{steps, parseXmlRuleNode(xnode, unions, symmetry)};
  }
  
  ensures(false, std::format("unknown tag {}", tag));
  std::unreachable();
}

struct Example {
  std::string title;
  std::string symbols;
  bool origin;
  Node program;
};

inline constexpr auto parseXmlExample(std::string title, std::string_view filepath) noexcept -> decltype(auto) {
  auto xexample = pugi::xml_document{};
  const auto result = xexample.load_file(std::data(filepath));
  ensures(result, std::format("Error while parsing xml ({}:{}) : {}", filepath, result.offset, result.description()));
  const auto xnode = xexample.first_child();

  const auto symbols = xnode.attribute("values").as_string();
  // ensure no duplicate
  const auto origin = xnode.attribute("origin").as_bool(false);

  auto program = parseXmlNode(xnode);
  if (xnode.name() != "sequence"s && xnode.name() != "markov"s)
    program = Markov{{program}};

  return Example{
    std::move(title),
    std::move(symbols), std::move(origin),
    std::move(program)
  };
}

}
}