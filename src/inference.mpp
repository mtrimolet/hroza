export module inference;

import std;
import glm;
import stormkit.Core;
import utils;
import geometry;

import grid;

using namespace stormkit;
using symbol = char;
using grid_view = std::mdspan<const symbol, std::dims<3>>;

export
struct DijkstraField {
  bool recompute, essential, inversed;
  std::optional<std::unordered_set<symbol>> substrate, zero;

  static inline constexpr auto parse(
    bool recompute, bool essential,
    std::string_view on,
    std::string_view from,
    std::string_view to
  ) noexcept -> decltype(auto) {
    static constexpr auto IGNORED = '*';
    auto&& zero = std::ranges::empty(from) ? to : from;
    return DijkstraField{
      recompute, essential,
      not std::ranges::empty(from),
      on == std::format("{}", IGNORED) ? std::nullopt : std::optional{on | std::ranges::to<std::unordered_set>()},
      zero == std::format("{}", IGNORED) ? std::nullopt : std::optional{zero | std::ranges::to<std::unordered_set>()}
    };
  }

  inline constexpr auto dijkstraMap(grid_view grid) const noexcept -> decltype(auto) {
    const auto g_sentinel = toSentinel(grid.extents());
    const auto neigh_size = math::Vector3U{3, 3, g_sentinel.z == 1 ? 1 : 3};
    const auto neigh_offset = neigh_size / 2;
    const auto neigh_margin = Area3U{neigh_offset, g_sentinel - neigh_offset};

    auto potential = Grid<std::optional<UInt>>{grid.extents(), std::nullopt};

    for (
      auto q = mdiota(g_sentinel)
        | std::views::filter([zero{this->zero}, &grid](auto&& u) noexcept {
            return zero == std::nullopt
                or zero->contains(grid[u.z, u.y, u.x]);
        })
        | std::views::transform([&potential](auto&& u) noexcept {
            potential[u] = 0u;
            return std::make_pair(u, 0u);
        })
        | std::ranges::to<std::queue>();
      not std::ranges::empty(q);
      q.pop()
    ) {
      auto&& [u, value] = q.front();
      const auto neighborhood = neigh_margin.intersect({u, neigh_size}) - neigh_offset;
      q.push_range(
        mdiota(neighborhood)
        | std::views::filter([substrate{this->substrate}, &potential, &grid](auto&& n) noexcept {
            return potential[n] == std::nullopt
               and (substrate == std::nullopt
                 or substrate->contains(grid[n.z, n.y, n.x])
               );
        })
        | std::views::transform([&potential, &value](auto&& n) noexcept {
            potential[n] = value + 1;
            return std::make_pair(n, value + 1);
        })
      );
    }

    return potential;
  }
};