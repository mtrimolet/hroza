export module inference;

import std;
import glm;
import stormkit.Core;
import utils;
import geometry;

import grid;
import rule;

using namespace stormkit;
using symbol = char;
using grid_view = std::mdspan<const symbol, std::dims<3>>;

inline constexpr auto propagate(auto&& initial, auto&& unfold) noexcept -> decltype(auto) {
  for (
    auto&& q = std::forward<decltype(initial)>(initial) | std::ranges::to<std::queue>();
    not std::ranges::empty(q);
    q.pop()
  ) q.push_range(unfold(q.front()));
}

export
using Potential = Grid<double>;

export
/** Produce distance potential through substrate */
struct DijkstraField {
  bool recompute, essential, inversed;
  std::optional<std::unordered_set<symbol>> substrate, zero;

  static inline constexpr auto parse(
    bool recompute, bool essential,
    std::string_view on,
    std::string_view from,
    std::string_view to
  ) noexcept -> decltype(auto) {
    static constexpr auto IGNORED = '*';
    auto&& zero = std::ranges::empty(from) ? to : from;
    return DijkstraField{
      recompute, essential,
      not std::ranges::empty(from),
      on == std::format("{}", IGNORED) ? std::nullopt : std::optional{on | std::ranges::to<std::unordered_set>()},
      zero == std::format("{}", IGNORED) ? std::nullopt : std::optional{zero | std::ranges::to<std::unordered_set>()}
    };
  }

  inline constexpr auto dijkstraMap(grid_view grid) const noexcept -> decltype(auto) {
    auto potential = Potential{grid.extents(), inversed ? -std::numeric_limits<double>::infinity() : std::numeric_limits<double>::infinity()};
    auto&& p_area = potential.area();
    propagate(
      mdiota(p_area)
        | std::views::filter([&zero{zero}, &grid](auto&& u) noexcept {
            return zero == std::nullopt
                or zero->contains(grid[u.z, u.y, u.x]);
        })
        | std::views::transform([&potential](auto&& u) noexcept {
            potential[u] = 0.0;
            return std::make_pair(u, 0.0);
        }),
      [&](auto&& front) noexcept {
        static constexpr auto neigh_size = 3u * math::Vector3U{1, 1, 1};
        static constexpr auto neigh_shift = -static_cast<math::Vector3I>(neigh_size) / 2;
        static constexpr auto neigh = Area3I{neigh_shift, neigh_size};

        auto&& [u, p] = front;
        auto&& new_us = (neigh + u).umeet(p_area);
        auto&& new_p = inversed ? p - 1.0 : p + 1.0;
        return mdiota(new_us)
          | std::views::filter([&, new_p](auto&& n) noexcept {
              return (inversed ? potential[n] < new_p : potential[n] > new_p)
                 and (substrate == std::nullopt
                   or substrate->contains(grid[n.z, n.y, n.x])
                 );
          })
          | std::views::transform([&, new_p](auto&& n) noexcept {
              potential[n] = new_p;
              return std::make_pair(n, new_p);
          });
      }
    );

    return potential;
  }
};

export struct Observation {
  symbol from;
  std::unordered_set<symbol> to;
};

// inline constexpr auto future(std::unordered_map<symbol, const Observation> obs, grid_view grid) noexcept -> decltype(auto) {
//   auto&& changes = std::vector<Change<symbol>>{};
//   auto&& f = mdiota(grid.area())
//     | std::views::transform([&obs, &changes, &grid](auto&& u) noexcept {
//         auto&& c = grid[u.z, u.y, u.x];
//         if (not obs.contains(c)) return std::optional<std::unordered_set<symbol>>();
//         changes.emplace_back(c, obs.at(c).from);
//         return std::optional{obs.at(c).to};
//     })
//     | std::ranges::to<Grid<std::unordered_set<symbol>>>(grid.extents());

//   return std::make_pair(std::move(changes), std::move(f));
// }

inline constexpr auto forward(
  grid_view grid,
  std::span<const Rule> rules
) noexcept -> decltype(auto) {
  auto potentials = std::unordered_map<symbol, Potential>{};

  propagate(
    mdiota(grid.extents())
      | std::views::transform([&grid, &potentials](auto&& u) noexcept {
          auto&& c = grid[u.z, u.y, u.x];
          potentials.try_emplace(c, grid.extents(), std::numeric_limits<double>::infinity());
          potentials.at(c)[u] = 0.0;
          return std::make_pair(c, u);
      }),
    [&potentials, &rules](auto&& front) noexcept {
      auto&& [c, u] = front;
      auto&& potential = potentials.at(c);
      auto&& p_area = potential.area();

      auto&& p = potential[u];
      auto&& new_p = p + 1.0;
  
      return rules 
        | std::views::transform([&, p_area](auto&& rule) noexcept {
            auto&& neigh = rule.backward_neighborhood();
            auto&& zone = (neigh + u).umeet(p_area);
            return mdiota(zone)
              | std::views::transform([&rule](auto&& u) noexcept {
                  return std::views::zip(
                    mdiota(rule.area() + u),
                    rule.input,
                    rule.output
                  );
              })
              | std::views::filter([&potentials, p](auto&& _uios) noexcept {
                  return std::ranges::none_of(
                    _uios | std::views::filter([](auto&& _uio) static noexcept {
                      auto&& [u, i, o] = _uio;
                      return i != std::nullopt;
                    }),
                    bindBack(std::greater{}, p),
                    [&potentials](auto&& _uio) noexcept {
                      auto&& [u, i, o] = _uio;
                      // return std::optional{0.0};
  
                      // In original MarkovJunior code, we use int-coded bitset for rule input,
                      // and the following type-mismatch is solved using a mysterious "least index of active bit"
                      // which is very dependant to the specific fact that we use an _ordered_ repr. of a bitset...
                      // That's magic ! 
                      // .. unless that bit is expected to be the only one active
                      //
                      // Original code (our 'i' is the 'w'): `System.Numerics.BitOperations.TrailingZeroCount(w)`
                      // Or is the provided order of the symbols so important that we need to move rule.input to an ordered set ?
                      // return potentials.contains(i)
                      //   ? potentials.at(i)[u]
                      //   : std::optional{0u};

                      auto&& e = *i
                        | std::views::filter([&potentials, &u](auto&& i) noexcept {
                            return potentials.contains(i)
                               and potentials.at(i)[u] != std::numeric_limits<double>::infinity();
                        })
                        | std::views::transform([&potentials, &u](auto&& i) noexcept {
                            return potentials.at(i)[u];
                        })
                        | std::ranges::to<std::set>();
                      if (std::ranges::empty(e)) return std::numeric_limits<double>::infinity();
  
                      return *std::ranges::max_element(e);
                    }
                  );
              })
              | std::views::join;
          }
        )
        | std::views::join
        | std::views::filter([&potentials](auto&& _uio) noexcept {
            auto&& [u, i, o] = _uio;
            return o != std::nullopt
               and potentials.contains(*o)
               and potentials.at(*o)[u] == std::numeric_limits<double>::infinity();
        })
        | std::views::transform([&potentials, new_p](auto&& _uio) noexcept {
            auto&& [u, i, o] = _uio;
            potentials.at(*o)[u] = new_p;
            return std::make_pair(*o, u);
        });
    }
  );

  return potentials;
}
