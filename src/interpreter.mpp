export module interpreter;

import std;
import stormkit.Core;
import pugixml;
import grid;
import model;
import symmetry;
import utils;
import xml_tree_walker;

using namespace stormkit;

struct Branch {
  auto go(Grid& grid) -> std::optional<Branch>{ return std::nullopt;}
  void reset() {}

  bool operator!=(const Branch &other) const noexcept { return true; }
};

export struct Interpreter {
private:
  Grid grid;
  Branch root;
  Boolean origin;

public:
  Interpreter(const Model &model)
    : Interpreter{model.doc.first_child(), {model.MX, model.MY, model.MZ}} {}
  Interpreter(const pugi::xml_node &xelem, Grid::Size&& size)
    : grid{parseGrid(xelem, std::move(size))},
      origin{xelem.attribute("origin").as_bool(false)} {

      const auto symmetry = symmetry::getSymmetry(
        get<2>(grid.size) == 1, xelem.attribute("symmetry").as_string());

    std::println("nodes:");

    auto prev = 0;
    for (auto &&xnode : XMLDepthWalker{xelem}) {
      const auto attributes = xnode.attributes() 
          | std::views::transform([](auto attr) {
              return std::format("{}={}", attr.name(), attr.value());
            });

      const auto name = std::string{xnode.name()};
      std::println("{}{}", name, attributes);

      std::optional<Node> node = std::nullopt;
      if (name == "one")
        node = OneNode::parse(xnode, symmetry, grid.size);
      if (name == "markov")
        node = MarkovNode::parse(xnode, symmetry, grid.size);

      ensures(static_cast<bool>(node),
              std::format("unknown node name '{}' [:{}]", name,
                          xnode.offset_debug()));
    }
    std::println();

    // root = topnode is Branch ? topnode : new MarkovNode{topnode};
  }

  auto run(UInt seed) -> std::generator<const Grid&> {
    auto random = std::mt19937{seed};

    std::println("waves: {}", grid.waves
      | std::views::transform([](auto&& x){
          return std::make_pair(get<0>(x), get<1>(x));
        }));
    if (origin) grid.states.at(grid.center()) = 1;

    auto current = std::optional{root};

    co_yield grid;
    while (current != std::nullopt) {
      current = current->go(grid);
      co_yield grid;
    }
  }
};