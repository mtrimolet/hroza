export module interpreter;

import std;
import stormkit.Core;
import pugixml;
import grid;
import node;
import model;
import symmetry;
import utils;
import xml_tree_walker;
import frozen;

using namespace stormkit;
using namespace std::literals;

export struct Interpreter {
public:

  Grid grid;
  std::variant<MarkovNode> root;
  // std::vector<ExecutionNode> nodes;
  // std::vector<std::variant<MarkovNode, OneNode>> nodes;

  static inline constexpr auto parse(const pugi::xml_node &xroot, Size&& size) noexcept -> decltype(auto) {
    auto grid = Grid::parse(xroot, std::move(size));

    std::println("nodes:");

    const auto symmetry = symmetry::getSymmetry(
        std::get<0>(grid.size) == 1, xroot.attribute("symmetry").as_string());

    const auto name = std::string{xroot.name()};

    auto node = std::optional<std::variant<OneNode, MarkovNode>>{};
    if (name == "one")
      node = OneNode::parse(xroot, grid, symmetry);
    else if (name == "markov")
      node = MarkovNode::parse(xroot, grid, symmetry);
    
    ensures(node != std::nullopt, std::format("unknown node name '{}' [:{}]", name, xroot.offset_debug()));
    
    std::println();

    return Interpreter{std::move(grid), node.value().visit(Visitor{
      [](MarkovNode& n) { return n; }, 
      [](auto& n){ return MarkovNode{{n}}; },
    })};
  }

  inline auto run(UInt seed) noexcept -> std::generator<const Grid&> {
    auto random = std::mt19937{seed};

    auto changes = std::vector<math::Vector3I>{};

    grid.reset();
    co_yield grid;

    for (const auto success : root.visit([&](MarkovNode& n){
      return n.execute(grid, changes, std::ranges::end(changes));
    }))
      co_yield grid;
  }
};