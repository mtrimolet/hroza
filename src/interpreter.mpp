export module interpreter;

import std;
import stormkit.Core;
import pugixml;
import grid;
import node;
import model;
import symmetry;
import utils;
import xml_tree_walker;
import frozen;

using namespace stormkit;
using namespace std::literals;

export struct Interpreter {
public:
  using Node = std::variant<OneNode, AllNode, MarkovNode, SequenceNode>;
  using BranchNode = std::variant<MarkovNode, SequenceNode>;

  Grid grid;
  BranchNode root;

  static inline constexpr auto parse(const pugi::xml_node &xroot, Size&& size) noexcept -> decltype(auto) {
    auto grid = Grid::parse(xroot, std::move(size));

    std::println("nodes:");

    const auto symmetry = symmetry::getSymmetry(
        std::get<0>(grid.size) == 1, xroot.attribute("symmetry").as_string());

    const auto name = std::string{xroot.name()};

    auto node = std::optional<Node>{};
    if (name == "one")
      node = OneNode::parse(xroot, grid, symmetry);
    else if (name == "all")
      node = AllNode::parse(xroot, grid, symmetry);
    else if (name == "markov")
      node = MarkovNode::parse(xroot, grid, symmetry);
    else if (name == "sequence")
      node = SequenceNode::parse(xroot, grid, symmetry);
    
    ensures(node != std::nullopt, std::format("unknown node name '{}' [:{}]", name, xroot.offset_debug()));
    
    std::println();

    return Interpreter{std::move(grid), node.value().visit(Visitor{
      [](OneNode& n){ return BranchNode{MarkovNode{{n}}}; },
      [](AllNode& n){ return BranchNode{MarkovNode{{n}}}; },
      [](auto& n) { return BranchNode{n}; },
    })};
  }

  inline auto run(UInt seed) noexcept -> std::generator<const Grid&> {
    auto rg = std::mt19937{seed};
    auto changes = std::vector<math::Vector3I>{};

    grid.reset();
    co_yield grid;

    for (const auto success : root.visit([&](auto& n){
      return n.execute(grid, changes, std::ranges::end(changes), rg);
    }))
      co_yield grid;
  }
};