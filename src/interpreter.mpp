export module interpreter;

import std;
import stormkit.Core;
import pugixml;
import grid;
import model;
import symmetry;
import utils;

using namespace stormkit;

struct Branch {
  auto go(Grid& grid) -> std::optional<Branch>{ return std::nullopt;}
  void reset() {}

  bool operator!=(const Branch &other) const noexcept { return true; }
};

export struct Interpreter {
private:
  Grid grid;
  Branch root;
  Boolean origin;

public:
  Interpreter(const Model &model)
    : Interpreter{model.doc.first_child(), {model.MX, model.MY, model.MZ}} {}
  Interpreter(const pugi::xml_node &xelem, Grid::Size&& size)
    : grid{parseGrid(xelem, std::move(size))},
      origin{xelem.attribute("origin").as_bool(false)} {

      const auto symmetry = symmetry::getSymmetry(
        get<2>(grid.size) == 1, xelem.attribute("symmetry").as_string());

      // const auto topnode = Node.Factory(xelem, symmetry, *this, grid);
      // ensures(topnode != Node{});

      // root = topnode is Branch ? topnode : new MarkovNode{topnode, *this};
  }

  auto run(UInt seed) -> std::generator<const Grid&> {
    auto random = std::mt19937{seed};

    std::println("waves: {}", grid.waves
      | std::views::transform([](auto&& x){
          return std::make_pair(get<0>(x), get<1>(x));
        }));
    if (origin) grid.states.at(grid.center()) = 1;

    auto current = std::optional{root};

    co_yield grid;
    while (current != std::nullopt) {
      current = current->go(grid);
      co_yield grid;
    }
  }
};