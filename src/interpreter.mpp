export module interpreter;

import std;
import stormkit.Core;
import pugixml;
import grid;
import node;
import model;
import symmetry;
import utils;
import xml_tree_walker;
import frozen;

using namespace stormkit;
using namespace std::literals;

export struct Interpreter {
private:
  Grid grid;
  std::variant<MarkovNode> root;
  Boolean origin;

  static constexpr auto node_types = frozen::set{ 
    "one"sv,
    // "all"sv,
    // "prl"sv,
    "markov"sv,
    // "sequence"sv,
    // "path"sv,
    // "map"sv,
    // "convolution"sv,
    // "convchain"sv,
    // "wfc"sv
  };

  static constexpr auto branch_types = frozen::set{ 
    "markov"sv,
    // "sequence"sv,
    // "map"sv,
    // "wfc"sv
  };

public:
  Interpreter(const Model &model)
      : Interpreter{model.doc.first_child(), {model.MX, model.MY, model.MZ}} {}
  Interpreter(const pugi::xml_node &xelem, Grid::Size&& size)
      : grid{parseGrid(xelem, std::move(size))},
        origin{xelem.attribute("origin").as_bool(false)} {

    const auto symmetry = symmetry::getSymmetry(
        std::get<2>(grid.size) == 1, xelem.attribute("symmetry").as_string());

    std::println("nodes:");

    auto nodes = std::vector<std::variant<MarkovNode, OneNode>>{};
    for (auto &&xnode : XMLDepthWalker{xelem}) {
      const auto attributes = xnode.attributes() 
          | std::views::transform([](auto attr) {
              return std::format("{}={}", attr.name(), attr.value());
            });

      const auto name = std::string{xnode.name()};
      ensures(node_types.contains(name), std::format("unknown node name '{}' [:{}]", name, xnode.offset_debug()));

      std::println("{}{}", name, attributes);

      if (name == "one")
        nodes.push_back(OneNode::parse(xnode, grid, symmetry));
      // else if (name == "markov")
      //   node.push_back(MarkovNode::parse(xnode, grid, symmetry));
      else
        ensures(false, std::format("failed to load '{}' node [:{}]", name, xnode.offset_debug()));
    }
    std::println();

    auto& _root = nodes.at(0);
    root = std::holds_alternative<MarkovNode>(_root)
      ? std::get<MarkovNode>(_root)
      : MarkovNode{std::get<OneNode>(_root)};
  }

  auto run(UInt seed) -> std::generator<const Grid&> {
    auto random = std::mt19937{seed};

    auto changes = std::vector<math::Vector3I>{};
    auto first = std::vector<UInt>{0u};

    if (origin) grid.states.at(grid.center()) = 1;

    auto current = std::optional{root};
    co_yield grid;

    while (current != std::nullopt) {
      if (std::holds_alternative<MarkovNode>(current.value())) {
        auto& go = std::get<MarkovNode>(current.value());
        current = go(grid, changes, first);
        first.push_back(std::ranges::size(changes));
      }
      co_yield grid;
    }
  }
};