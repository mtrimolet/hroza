export module executionnode;

import std;
import stormkit.Core;

import grid;

using namespace stormkit;
using symbol = char;

export {

using Action = std::function<std::vector<Change<symbol>>(TracedGrid<symbol>&)>;

}

struct ActionNode {
  Action action;
  inline constexpr auto operator()(TracedGrid<symbol>& grid) noexcept -> std::vector<Change<symbol>> {
    auto&& changes = action(grid);
    std::ranges::for_each(changes, bindFront(&TracedGrid<symbol>::apply, &grid));
    return changes;
  }
};

export {

struct NoLimit : ActionNode {
  inline auto operator()(TracedGrid<symbol>& grid) noexcept -> std::generator<std::vector<Change<symbol>>> {
    auto&& changes = ActionNode::operator()(grid);
    if (std::ranges::empty(changes)) co_return;
    co_yield std::move(changes);
  }
};

struct Limit : ActionNode {
  UInt count;
  inline constexpr Limit(UInt _count, Action&& _action) noexcept : ActionNode{std::move(_action)}, count{_count} {}

  inline auto operator()(TracedGrid<symbol>& grid) noexcept -> std::generator<std::vector<Change<symbol>>> {
    if (count == 0) co_return;
    
    auto&& changes = ActionNode::operator()(grid);
    if (std::ranges::empty(changes)) co_return;

    count--;
    co_yield std::move(changes);
  }
};

using ExecutionNode = std::function<std::generator<std::vector<Change<symbol>>>(TracedGrid<symbol>&)>;

struct Sequence {
  std::vector<ExecutionNode> nodes;
  inline auto operator()(TracedGrid<symbol>& grid) noexcept -> std::generator<std::vector<Change<symbol>>> {
    auto&& current_node = std::ranges::begin(nodes);
    while (current_node != std::ranges::end(nodes)) {
      auto&& found = false;
      for (auto&& changes : (*current_node)(grid)) {
        if (not found) found = true;
        co_yield changes;
      }
      if (not found)
        current_node++;
    }
  }
};

struct Markov {
  std::vector<ExecutionNode> nodes;
  inline auto operator()(TracedGrid<symbol>& grid) noexcept -> std::generator<std::vector<Change<symbol>>> {
    auto&& current_node = std::ranges::begin(nodes);
    while (current_node != std::ranges::end(nodes)) {
      auto&& found = false;
      for (auto&& changes : (*current_node)(grid)) {
        if (not found) found = true;
        co_yield changes;
      }
      if (found)
        current_node = std::ranges::begin(nodes);
      else
        current_node++;
    }
  }
};

}