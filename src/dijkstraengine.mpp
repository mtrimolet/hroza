export module dijkstraengine;

import std;
import glm;
import stormkit.core;
import utils;
import geometry;

import grid;
import rewriterule;
import match;
import rewriteengine;
import forceengine;

using namespace stormkit;

export {

/** Produce distance potential through substrate */
struct DijkstraField {
  bool recompute, essential, inversed;
  std::unordered_set<char> substrate, zero;

  auto potential(Grid<char>::ConstView grid) const noexcept -> Potential;
};

using DijkstraFields = std::unordered_map<char, DijkstraField>;

struct DijkstraEngine : ForceEngine {
  DijkstraFields fields;

  inline constexpr DijkstraEngine() noexcept = default;

  inline constexpr DijkstraEngine(double temperature, DijkstraFields&& _fields) noexcept
  : ForceEngine{temperature, {}}, fields{std::move(_fields)}
  {}

  auto updatePotentials(Grid<char>::ConstView grid) noexcept -> void;

  inline constexpr auto essential_missing() const noexcept -> decltype(auto) {
    return std::ranges::any_of(fields, [&](auto&& _f) noexcept {
      auto&& [c, f] = _f;
      return f.essential and not potentials.contains(c);
    });
  }
};

}
