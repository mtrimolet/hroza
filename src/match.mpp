export module match;

import std;
import glm;
import stormkit.core;
import geometry;

import grid;
import rewriterule;

import log;

using namespace stormkit;

export
struct Match {
  static constexpr auto IGNORED_SYMBOL = '*';
  
  std::span<const RewriteRule> rules;
  math::Vector3U u;
  RangeOffset    r;

  // inline constexpr Match(math::Vector3U _u, RewriteRule& _rule) noexcept
  // : u{_u}, rule{_rule} {}

  // inline constexpr Match(const Match& other) noexcept
  // : rules{other.rules}, u{other.u}, r{other.r} {}
  // inline constexpr auto operator=(Match&& other) noexcept -> Match& {
  //   u = other.u; rule = other.rule;
  //   return *this;
  // }

  // inline constexpr auto operator==(const Match& other) const noexcept -> bool {
  //   return rules == other.rules u == other.u and rules[r] == other.rules[other.r];
  // }

  inline constexpr auto area() const noexcept -> Area3U {
    return rules[r].area() + u;
  }

  auto conflict(const Match& other) const noexcept -> bool;
  auto match(const Grid<char>& grid, const RewriteRule::Unions& unions) const noexcept -> bool;
  auto changes(const Grid<char>& grid) const noexcept -> std::vector<Change<char>>;
};

export template <>
struct std::formatter<Match> {
  template<class ParseContext>
  constexpr ParseContext::iterator parse(ParseContext& ctx)
  {
      auto it = ctx.begin();
      if (it == ctx.end())
          return it;

      // if (*it == '#')
      // {
      //     quoted = true;
      //     ++it;
      // }
      if (it != ctx.end() && *it != '}')
          throw std::format_error("Invalid format args for RewriteRule.");

      return it;
  }

  template<class FmtContext>
  FmtContext::iterator format(const Match& m, FmtContext& ctx) const
  {
      std::ostringstream out;
      // if (quoted)
      //     out << std::quoted(s);
      // else
          out << std::format("{} {}", m.u, m.rules[m.r]);

      return std::ranges::copy(std::move(out).str(), ctx.out()).out;
  }
};
