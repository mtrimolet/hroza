export module node;

import std;
import glm;
import stormkit.Core;
import pugixml;
import grid;
import rule;
import symmetry;
import stride_view;
import utils;

using namespace stormkit;

export struct RuleNode {

public:
  std::vector<Rule> rules;

protected:
  using Match = std::tuple<UInt, math::Vector3I>;
  std::vector<Match> matches;

  // std::optional<UInt> lastMatchedTurn;
  // size(matchMask) == size(rules);
  // size(matchMask[i]) == grid_size[0] * grid_size[1] * grid_size[2];
  std::vector<std::vector<bool>> matchMask;

  // size(last) == size(rules)
  // std::vector<bool> last;

public:
  RuleNode(const Size &grid_size, std::vector<Rule> &&_rules, auto steps) noexcept
      : rules{std::move(_rules)},
        matchMask(std::ranges::size(rules)) {
    const auto s = std::get<0>(grid_size) * std::get<1>(grid_size) * std::get<2>(grid_size);
    for (auto& m : matchMask) m.resize(s);
  };

  inline constexpr auto addMatch(const Size &grid_size, UInt r, math::Vector3I u) noexcept -> void {
    matchMask[r][toIndex(u, grid_size)] = true;
    matches.push_back(std::make_tuple(r, u));
  }

  static inline constexpr auto inBounds(const math::Vector3I &u,
                                        const math::Vector3I &b1,
                                        const math::Vector3I &b2) noexcept
      -> bool {
    const auto lower = math::Vector3I{
        std::min(b1.x, b2.x),
        std::min(b1.y, b2.y),
        std::min(b1.z, b2.z),
    };
    const auto upper = math::Vector3I{
        std::max(b1.x, b2.x),
        std::max(b1.y, b2.y),
        std::max(b1.z, b2.z),
    };
    return lower.x <= u.x and u.x <= upper.x
       and lower.y <= u.y and u.y <= upper.y
       and lower.z <= u.z and u.z <= upper.z;
  }

  inline constexpr auto reset() noexcept -> void {
    matches.clear();

    for (auto& m : matchMask) {
      const auto l = std::ranges::size(m);
      m.clear();
      m.resize(l);
    }
  }

  inline constexpr auto loadMatches(Grid &grid, const std::vector<math::Vector3I> &changes,
                    const std::vector<math::Vector3I>::iterator &next_change)
      noexcept -> bool {

    const auto &[MZ, MY, MX] = grid.size;
    const auto M = math::Vector3I{MX, MY, MZ};

    if (next_change != std::ranges::end(changes)) {
      for (const auto &u : std::ranges::subrange(next_change, std::ranges::end(changes))) {
        const auto &value = grid.at(u);
        for (const auto &[rule, r] : std::views::zip(rules, std::views::iota(0u))) {
          const auto &[IMZ, IMY, IMX] = rule.input_size;
          const auto IM = math::Vector3I{IMX, IMY, IMZ};

          for (const auto &shift : rule.ishifts.at(value)) {
            const auto s = u - shift;

            if (not inBounds(s, {0, 0, 0}, M - IM))
              continue;
            if (not matchMask.at(r).at(toIndex(s, grid.size)) and grid.matches(rule, s))
              addMatch(grid.size, r, s);
          }
        }
      }
    } else {
      matches.clear();
      for (const auto &[rule, r] : std::views::zip(rules, std::views::iota(0u))) {
        const auto &[IMZ, IMY, IMX] = rule.input_size;
        const auto IM = math::Vector3I{IMX, IMY, IMZ};

        for (const auto &z : std::views::iota(IMZ - 1, MZ) | std::views::stride(IMZ))
        for (const auto &y : std::views::iota(IMY - 1, MY) | std::views::stride(IMY))
        for (const auto &x : std::views::iota(IMX - 1, MX) | std::views::stride(IMX)) {
          const auto u = math::Vector3I{x, y, z};

          const auto &value = grid.at(u);
          for (const auto &shift : rule.ishifts.at(value)) {
            const auto s = u - shift;

            if (not inBounds(s, {0, 0, 0}, M - IM))
              continue;
            if (grid.matches(rule, s))
              addMatch(grid.size, r, s);
          }
        }
      }
    }

    return true;
  }
};

export struct OneNode : RuleNode {

  OneNode(const Size &grid_size, std::vector<Rule> &&rules, UInt steps) noexcept
      : RuleNode{grid_size, std::move(rules), steps} {};

  static inline constexpr auto parse(const pugi::xml_node &xone, const Grid &grid,
                    const symmetry::subgroup &parentSymmetry) noexcept -> OneNode {
    const auto attributes = xone.attributes()
        | std::views::transform([](auto attr) {
            return std::format("{}={}", attr.name(), attr.value());
          });
    std::println("one{}", attributes);

    auto xrules = xone.children("rule") | std::ranges::to<std::vector>();
    if (std::ranges::empty(xrules))
      xrules.push_back(xone);

    auto rules = xrules
      | std::views::transform([&grid, &parentSymmetry](auto &xrule) {
          auto rule = Rule::parse(xrule, grid.waves, grid.values);

          const auto symmetry_string =
              std::string{xrule.attribute("symmetry").as_string()};
          const auto &subgroup = std::empty(symmetry_string)
              ? parentSymmetry
              : symmetry::getSymmetry(std::get<0>(grid.size) == 1,
                                      symmetry_string);

          return rule.symmetries(std::get<0>(grid.size) == 1, subgroup);
        })
      | std::views::join
      | std::ranges::to<std::vector>();

    return OneNode{grid.size, std::move(rules),
                   xone.attribute("steps").as_uint(0u)};
  }

  static inline constexpr auto apply(Grid& grid, const Rule &rule, const math::Vector3I &u) 
      noexcept -> std::vector<math::Vector3I> {
    return std::views::zip(rule.output, std::views::iota(0u)
        | std::views::transform([&rule, &u](auto i){ return u + fromIndex(i, rule.output_size); }))
      | std::views::filter([&grid](const auto& v){
          const auto& [newValue, s] = v;
          return newValue != 0xff and newValue != grid.at(s);
      })
      | std::views::transform([&grid](const auto v){
          const auto& [newValue, s] = v;
          grid[s] = newValue;
          return s;
      })
      | std::ranges::to<std::vector>();
  }

  auto inline constexpr randomMatch(const Grid &grid) noexcept -> std::optional<Match> {
    auto trashed = trash{matches};
    
    while (std::ranges::size(matches) > 0) {
      const auto matchIndex = std::rand() % std::ranges::size(matches);

      auto match = trashed.pop(matchIndex);
      const auto &[r, u] = match;
      matchMask[r][toIndex(u, grid.size)] = false;
      if (grid.matches(rules.at(r), u))
        return match;
    }
    return std::nullopt;
  }

  inline constexpr auto execute(Grid &grid, std::vector<math::Vector3I> &changes,
                  const std::vector<math::Vector3I>::iterator &next_change)
      noexcept -> bool {
    if (not loadMatches(grid, changes, next_change)) return false;

    auto m = randomMatch(grid);
    if (not m) return false;
    const auto &[r, u] = m.value();

    changes.insert_range(
      std::ranges::end(changes),
      apply(grid, rules.at(r), u));

    return true;
  }
};

export struct MarkovNode {
  std::vector<std::variant<OneNode, MarkovNode>> children;

  static inline constexpr auto parse(pugi::xml_node xmarkov, const Grid& grid,
      const symmetry::subgroup &parentSymmetry) noexcept -> MarkovNode {
    const auto attributes = xmarkov.attributes()
        | std::views::transform([](auto attr) {
            return std::format("{}={}", attr.name(), attr.value());
          });
    std::println("markov{}", attributes);

    const auto symmetry_string =
        std::string{xmarkov.attribute("symmetry").as_string()};
    const auto &subgroup = std::empty(symmetry_string)
        ? parentSymmetry
        : symmetry::getSymmetry(std::get<0>(grid.size) == 1,
                                symmetry_string);

    auto children = xmarkov.children()
      | std::views::transform([&](const auto& xnode){
          const auto name = std::string{xnode.name()};

          auto node = std::optional<std::variant<OneNode, MarkovNode>>{};
          if (name == "one")
            node = OneNode::parse(xnode, grid, subgroup);
          else if (name == "markov")
            node = MarkovNode::parse(xnode, grid, subgroup);

          ensures(node != std::nullopt, std::format("unknown node name '{}' [:{}]", name, xnode.offset_debug()));
          return node.value();
        })
        | std::ranges::to<std::vector>();

      return MarkovNode{children};
  }

  inline constexpr auto reset() noexcept -> void {
    for (auto& node : children) node.visit([](auto& n){ n.reset(); });
  }

  inline auto execute(Grid &grid, std::vector<math::Vector3I> &changes,
                  const std::vector<math::Vector3I>::iterator &next_change)
      noexcept -> std::generator<bool> {
    reset();
    auto child = std::ranges::begin(children);
    while (child != std::ranges::end(children)) {
      for (const auto success : child->visit(Visitor{
        [&](OneNode& n) -> std::generator<bool> { co_yield n.execute(grid, changes, std::ranges::end(changes)); },
        [&](MarkovNode& n) { return n.execute(grid, changes, std::ranges::end(changes)); },
      }))
        if (success) co_yield true;
        else { child++; break; }
    }
    co_yield false;
  }
};
};