export module node;

import std;
import stormkit.Core;

import grid;

using namespace stormkit;

export {

using Action = std::function<Grid<>(const Grid<>&)>;

inline auto limit(UInt count, const Action& action, const Grid<>& grid) noexcept -> std::generator<Grid<>> {
  auto current_grid = grid;
  for (; count > 0u; count--) {
    auto result_grid = action(current_grid);
    if (result_grid == current_grid) break;
    current_grid = result_grid;
    co_yield result_grid;
  }
}

struct Limit {
  UInt count;
  Action action;
  inline constexpr auto operator()(const Grid<>& grid) const noexcept-> decltype(auto) {
    return limit(count, action, grid);
  }
};

// inline auto no_limit(Action action, const Grid& grid) -> std::generator<Grid> {
//   auto current_grid = grid;
//   for (;;) {
//     auto result_grid = action(current_grid);
//     if (result_grid == current_grid) break;
//     current_grid = result_grid;
//     co_yield result_grid;
//   }
// }

inline constexpr auto no_limit(const Action& action, const Grid<>& grid) noexcept -> decltype(auto) {
  return limit(0xff, action, grid);
}

struct NoLimit {
  Action action;
  inline constexpr auto operator()(const Grid<>& grid) const noexcept -> decltype(auto) {
    return no_limit(action, grid);
  }
};

using Node = std::function<std::generator<Grid<>>(const Grid<>&)>;

inline auto sequence(std::span<const Node> nodes, const Grid<>& grid) noexcept -> std::generator<Grid<>> {
  auto current_grid = grid;
  for (auto current_node : nodes)
    for (auto result_grid : current_node(current_grid)) {
      current_grid = result_grid;
      co_yield result_grid;
  }
}

struct Sequence {
  std::vector<Node> nodes;
  inline constexpr auto operator()(const Grid<>& grid) const noexcept -> decltype(auto) {
    return sequence(nodes, grid);
  }
};

inline auto markov(std::span<const Node> nodes, const Grid<>& grid) noexcept -> std::generator<Grid<>> {
  auto current_grid = grid;
  auto current_node = std::ranges::begin(nodes);
  while (current_node != std::ranges::end(nodes)) {
    auto found = false;
    for (auto result_grid : (*current_node)(current_grid)) {
      if (not found) found = true;
      current_grid = result_grid;
      co_yield result_grid;
    }
    if (found)
      current_node = std::ranges::begin(nodes);
    else
      current_node++;
  }
}

struct Markov {
  std::vector<Node> nodes;
  inline constexpr auto operator()(const Grid<>& grid) const noexcept -> decltype(auto) {
    return markov(nodes, grid);
  }
};

}