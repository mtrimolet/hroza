export module node;

import std;
import glm;
import stormkit.Core;

import grid;

using namespace stormkit;

export {

template <class T>
using Change = std::tuple<math::Vector3U, T>;

template <class T>
using Action = std::function<std::vector<Change<T>>(const Grid<T>&)>;

template <class T>
inline auto limit(UInt count, const Action<T>& action, const Grid<T>& grid) noexcept -> std::generator<std::vector<Change<T>>> {
  auto current_grid = auto{grid};
  for (; count > 0u; count--) {
    auto changes = action(current_grid);
    if (std::ranges::empty(changes)) break;
    for (auto [u, value] : changes)
      current_grid.values[toIndex(u, current_grid.size)] = value;
    co_yield changes;
  }
}

template <class T>
struct Limit {
  UInt count;
  Action<T> action;
  inline constexpr auto operator()(const Grid<T>& grid) const noexcept-> decltype(auto) {
    return limit<T>(count, action, grid);
  }
};

template <class T>
inline auto no_limit(Action<T> action, const Grid<T>& grid) -> std::generator<std::vector<Change<T>>> {
  auto current_grid = auto{grid};
  for (;;) {
    auto changes = action(current_grid);
    if (std::ranges::empty(changes)) break;
    for (auto [u, value] : changes)
      current_grid.values[toIndex(u, current_grid.size)] = value;
    co_yield changes;
  }
}

template <class T>
struct NoLimit {
  Action<T> action;
  inline constexpr auto operator()(const Grid<T>& grid) const noexcept -> decltype(auto) {
    return limit<T>(0xff, action, grid);
  }
};

template <class T>
using Node = std::function<std::generator<std::vector<Change<T>>>(const Grid<T>&)>;

template <class T>
inline auto sequence(std::span<const Node<T>> nodes, const Grid<T>& grid) noexcept -> std::generator<std::vector<Change<T>>> {
  auto current_grid = auto{grid};
  for (auto current_node : nodes)
    for (auto changes : current_node(current_grid)) {
      if (std::ranges::empty(changes)) break;
      for (auto [u, value] : changes)
        current_grid.values[toIndex(u, current_grid.size)] = value;
      co_yield changes;
  }
}

template <class T>
struct Sequence {
  std::vector<Node<T>> nodes;
  inline constexpr auto operator()(const Grid<T>& grid) const noexcept -> decltype(auto) {
    return sequence<T>(nodes, grid);
  }
};

template <class T>
inline auto markov(std::span<const Node<T>> nodes, const Grid<T>& grid) noexcept -> std::generator<std::vector<Change<T>>> {
  auto current_grid = auto{grid};
  auto current_node = std::ranges::begin(nodes);
  while (current_node != std::ranges::end(nodes)) {
    auto found = false;
    for (auto changes : (*current_node)(current_grid)) {
      if (std::ranges::empty(changes)) break;
      if (not found) found = true;
      for (auto [u, value] : changes)
        current_grid.values[toIndex(u, current_grid.size)] = value;
      co_yield changes;
    }
    if (found)
      current_node = std::ranges::begin(nodes);
    else
      current_node++;
  }
}

template <class T>
struct Markov {
  std::vector<Node<T>> nodes;
  inline constexpr auto operator()(const Grid<T>& grid) const noexcept -> decltype(auto) {
    return markov<T>(nodes, grid);
  }
};

}