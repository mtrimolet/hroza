export module node;

import std;
import glm;
import stormkit.Core;
import pugixml;
import grid;
import rule;
import symmetry;
import stride_view;
import utils;

using namespace stormkit;

export
struct RuleNode {
private:
  const Grid::Size& grid_size;

public:
  std::vector<Rule> rules;

protected:
  using Match = std::tuple<UInt, UInt, UInt, UInt>; 
  std::vector<Match> matches;
  UInt matchCount;
  std::optional<UInt> lastMatchedTurn;
  std::vector<std::vector<Boolean>> matchMask;

public:
  RuleNode(const Grid::Size& grid_size, std::vector<Rule>&& rules) : grid_size{grid_size}, rules{rules} {};

  inline constexpr auto toGridIndex(const math::Vector3I& u) const noexcept {
    return  u.x
          + u.y * std::get<0>(grid_size)
          + u.z * std::get<0>(grid_size) * std::get<1>(grid_size);
  }

  auto add(UInt r, math::Vector3I u, std::vector<Boolean>& maskr) -> void {
      maskr.at(toGridIndex(u)) = true;

      auto match = std::make_tuple(r, u.x, u.y, u.z);
      if (matchCount < std::ranges::size(matches))
        matches.at(matchCount) = std::move(match);
      else
        matches.push_back(std::move(match));
      matchCount++;
  }

  static inline constexpr auto inBounds(const math::Vector3I& u, const math::Vector3I& b1, const math::Vector3I& b2) noexcept -> Boolean {
    const auto lower = math::Vector3I{
      std::min(b1.x, b2.x),
      std::min(b1.y, b2.y),
      std::min(b1.z, b2.z),
    };
    const auto upper = math::Vector3I{
      std::max(b1.x, b2.x),
      std::max(b1.y, b2.y),
      std::max(b1.z, b2.z),
    };
    return  lower.x < u.x and u.x < upper.x
        and lower.y < u.y and u.y < upper.y
        and lower.z < u.z and u.z < upper.z;
  }

  std::optional<RuleNode> operator()(Grid& grid, const std::vector<math::Vector3I>& changes, const std::vector<UInt>& first) noexcept {
    const auto& [MX, MY, MZ] = grid.size;
    const auto M = math::Vector3I{MX, MY, MZ};

    if (lastMatchedTurn) {
      for (const auto& u : changes | std::views::drop(first[lastMatchedTurn.value()])) {
        const auto& value = grid.at(u);
        for (const auto& [rule, maskr, r]
            : std::views::zip(rules, matchMask, std::views::iota(0u))) {
          const auto& [IMX, IMY, IMZ] = rule.input_size;
          const auto IM = math::Vector3I{IMX, IMY, IMZ};

          for (const auto& shift : rule.ishifts[value]) { 
            const auto s = u - shift;

            if (not inBounds(s, {0, 0, 0}, M - IM))
              continue;
            if (not maskr[toGridIndex(s)] and grid.matches(rule, u))
              add(r, u, maskr);
          }
        }
      }
    }
    else {
      for (const auto& [rule, maskr, r]
          : std::views::zip(rules, matchMask, std::views::iota(0u))) {
        const auto& [IMX, IMY, IMZ] = rule.input_size;
        const auto IM = math::Vector3I{IMX, IMY, IMZ};

        // fot (const auto& [x, y, z] : std::views::cartesian_product(
        //   std::views::iota(IMX - 1, MX) | std::views::stride(IMX),
        //   std::views::iota(IMY - 1, MY) | std::views::stride(IMY),
        //   std::views::iota(IMZ - 1, MZ) | std::views::stride(IMZ),
        // )) {}

        for (const auto& z : std::views::iota(IMZ - 1, MZ) | std::views::stride(IMZ)) {
        for (const auto& y : std::views::iota(IMY - 1, MY) | std::views::stride(IMY)) {
        for (const auto& x : std::views::iota(IMX - 1, MX) | std::views::stride(IMX)) {
          const auto u = math::Vector3I{x, y, z};

          const auto& value = grid.at(u);
          for (const auto& shift : rule.ishifts[value]) { 
            const auto s = u - shift;

            if (not inBounds(s, {0, 0, 0}, M - IM))
              continue;
            if (grid.matches(rule, u))
              add(r, u, maskr);
          }
        }}}
      }
    }

    return *this;
  }
};

export
struct OneNode : RuleNode {
  OneNode(const Grid::Size& grid_size, std::vector<Rule>&& rules) : RuleNode{grid_size, std::move(rules)} {};

  static auto parse(const pugi::xml_node &xelem,
                    const Grid& grid, const symmetry::subgroup &parentSymmetry)
      -> OneNode {
    auto xrules = xelem.children("rule") | std::ranges::to<std::vector>();
    if (std::ranges::empty(xrules)) xrules.push_back(xelem);

    auto rules = xrules
        | std::views::transform([&grid](auto& xrule) { 
            auto r = Rule::parse(xrule, grid.waves, grid.values);
            ensures(static_cast<bool>(r), std::format("parse_result: {}", r.error().description()));
            return std::views::single(r.value());
          })
        | std::views::join
        | std::ranges::to<std::vector>();

    return OneNode{grid.size, std::move(rules)};
  }

  std::optional<OneNode> operator()(Grid& grid, const std::vector<math::Vector3I>& changes, const std::vector<UInt>& first) noexcept {
        if (not RuleNode::operator()(grid, changes, first)) return std::nullopt;
        return *this;
        // RuleNode::lastMatchedTurn = ip.counter;

        // if (trajectory != null)
        // {
        //     if (counter >= trajectory.Length) return false;
        //     Array.Copy(trajectory[counter], grid.state, grid.state.Length);
        //     counter++;
        //     return true;
        // }

        // auto [R, X, Y, Z] = RandomMatch(ip.random);
        // if (R < 0) return std::nullopt;
        // else
        // {
        //     // last[R] = true;
        //     apply(rules[R], X, Y, Z);
        //     counter++;
        //     return true;
        // }
  }
};

template<class... Ts>
struct overloads : Ts... { using Ts::operator()...; };

export
struct MarkovNode {
  std::vector<std::variant<OneNode, MarkovNode>> children;
  // std::optional<MarkovNode> parent;
  Int n;

  MarkovNode() = default;
  ~MarkovNode() = default;
  MarkovNode(MarkovNode&&) = default;
  auto operator=(MarkovNode&&) -> MarkovNode& = default;
  MarkovNode(const MarkovNode&) = default;
  auto operator=(const MarkovNode&) -> MarkovNode& = default;

  MarkovNode(std::variant<OneNode, MarkovNode> child) : children{child} {}
  static auto parse(const pugi::xml_node &xelem,
                    const Grid& grid, const symmetry::subgroup &parentSymmetry)
      -> MarkovNode {
    return MarkovNode{};
  }

  std::optional<MarkovNode> operator()(Grid& grid, const std::vector<math::Vector3I>& changes, const std::vector<UInt>& first) noexcept {
    n = 0;

    MarkovNode& current = *this;
    for (auto& child : children | std::views::drop(n)) {
      if (child.visit(overloads{
        [&](MarkovNode& node) {
          current = std::move(node);
          return current(grid, changes, first) != std::nullopt;
        },
        [&](OneNode& node){
          return node(grid, changes, first) != std::nullopt;
        },
      }))
        return current;
    }
    return std::nullopt;
    // return current.parent;
  }
};
