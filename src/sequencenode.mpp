export module sequencenode;

import std;
import stormkit.Core;
import pugixml;

using namespace stormkit;
using namespace std::literals;

template <class T>
concept has_reset_method = requires(T&& n) {
  {n.reset()};
};

export template <class Node>
struct SequenceNode {
  static constexpr auto name = "sequence"s;

  std::vector<Node> children;
  std::vector<Node>::iterator current;

  SequenceNode() = default;
  SequenceNode(std::vector<Node>&& _children) : children{_children}, current{std::ranges::begin(children)} {}

  static inline constexpr auto parse(const pugi::xml_node& xseq, const auto& grid, auto&& parentSymmetry) noexcept -> SequenceNode {
    auto children = xseq.children()
      | std::views::filter([](const auto& xnode) constexpr { return xnode.name() != "union"sv; })
      | std::views::transform([&grid, &parentSymmetry](const auto& xnode) constexpr { return Node::parse(xnode, grid, parentSymmetry); })
      | std::ranges::to<std::vector>();

      return SequenceNode{std::move(children)};
  }

  inline constexpr auto reset() noexcept -> void {
    if constexpr (has_reset_method<Node>)
      for (auto& node : children) node.reset();
    current = std::ranges::begin(children);
  }

  inline auto execute(auto& grid, auto& changes, auto& rg) noexcept -> std::generator<bool> {
    reset();
    while (current != std::ranges::end(children)) {
      for (const auto success : current->execute(grid, changes, rg))
        if (success) co_yield true;
        else { current++; break; }
    }
    co_yield false;
  }
};