export module geometry;

import std;
import glm;
import stormkit.Core;

using namespace stormkit;

export {

//////////////////////////////////
// Enrichment of math::Vector3U //
//////////////////////////////////

// glm only provides `dot` for vectors of floating-point number types

inline constexpr auto dot(const math::Vector3U& a, const math::Vector3U& b) noexcept -> decltype(auto) {
  return a.x * b.x
       + a.y * b.y
       + a.z * b.z;
}

// We're using the same component-wise behavior as standard glm functions (see comparators below)

inline constexpr auto min(const math::Vector3U& a, const math::Vector3U& b) noexcept -> decltype(auto) {
  return math::Vector3U{
    std::min(a.x, b.x),
    std::min(a.y, b.y),
    std::min(a.z, b.z),
  };
}

inline constexpr auto max(const math::Vector3U& a, const math::Vector3U& b) noexcept -> decltype(auto) {
  return math::Vector3U{
    std::max(a.x, b.x),
    std::max(a.y, b.y),
    std::max(a.z, b.z),
  };
}

///////////////////////////////////
// Comparators of math::Vector3U //
///////////////////////////////////

template <>
struct std::equal_to<math::Vector3U> {
  inline constexpr auto operator()(const math::Vector3U& a, const math::Vector3U& b) const noexcept -> bool {
    return math::all(math::equal(a, b));
  }
};

// maybe implement partial/weak/string ordering(s)

/* Memo

namespace math {
  std::function<math::Vector<E, bool>(math::Vector<E, T>, math::Vector<E, T>)>
    lessThan, lessThanEqual, greaterThan, greaterThanEqual;
}

extern math::Vector<E, T> a,b;

assert(
      math::lessThan(a, b)
  ==  math::greaterThan(b, a)
  and
      math::lessThanEqual(a, b)
  ==  math::greaterThanEqual(b, a)
);

assert(
      not math::lessThan(a, b)
  ==  math::greaterThanEqual(a, b)
  and
      not math::lessThanEqual(a, b)
  ==  math::greaterThan(a, b)
);

extern math::Vector<E, bool> c;

assert(
      not math::all(c)
  ==  math::any(not c)
);

*/

template <RangeExtent E, meta::IsArithmetic T>
struct Area {
  using Position = math::Vector<E, T>;
  using Extents = math::Vector<E, std::make_unsigned_t<UInt>>;

  Position u;
  Extents size;

  Area(Position _u, Extents _size) noexcept
    : u{_u}, size{_size} {}

  Area(Extents _size) noexcept
    : Area{{}, _size} {}

  Area() noexcept = default;

  template <meta::IsArithmetic T2>
  Area(const Area<E, T2>& other) noexcept
    : Area{other.u, other.size} {}

  inline constexpr auto sentinel() const noexcept -> decltype(auto) {
    return u + static_cast<Position>(size);
  }

  inline constexpr auto contains(const Position& v) const noexcept -> decltype(auto) {
    return math::all(math::lessThanEqual(u, v))
       and math::all(math::lessThan(v, sentinel()));
  }

  inline constexpr auto operator+(const Area& d) const noexcept -> decltype(auto) {
    return Area{u + d.u, size + d.size};
  }

  inline constexpr auto operator-(const Area& d) const noexcept -> decltype(auto) {
    return Area{u - d.u, size - d.size};
  }

  inline constexpr auto operator+(const Position& d) const noexcept -> decltype(auto) {
    return operator+(Area{d, {}});
  }

  inline constexpr auto operator-(const Position& d) const noexcept -> decltype(auto) {
    return operator-(Area{d, {}});
  }

  inline constexpr auto operator*(T r) const noexcept -> decltype(auto) {
    return Area{u * r, size * abs(r)};
  }

  inline constexpr auto operator/(T r) const noexcept -> decltype(auto) {
    return Area{u / r, size / abs(r)};
  }

  inline constexpr auto overlaps(const Area& other) const noexcept -> decltype(auto) {
    return math::all(math::lessThan(      u, other.sentinel()))
       and math::all(math::lessThan(other.u,       sentinel()));
  }

  inline constexpr auto meet(const Area& other) const noexcept -> decltype(auto) {
    if (not overlaps(other)) return Area{};
    const auto v = max(u, other.u);
    return Area{
      v,
      min(sentinel(), other.sentinel()) - v
    };
  }

  inline constexpr auto join(const Area& other) const noexcept -> decltype(auto) {
    const auto v = min(u, other.u);
    return Area{
      v,
      max(sentinel(), other.sentinel()) - v
    };
  }
};

using Area3U = Area<3, UInt>;
using Area3I = Area<3, Int>;

inline constexpr auto xreflected(const Area3U& a) noexcept -> decltype(auto) {
  auto size = auto{a.size};
  return Area3U{
    /* u -> { size.x - u.x - 1u, u.y, u.z } */
    a.u, std::move(size)
  };
}

inline constexpr auto xyrotated(const Area3U& a) noexcept -> decltype(auto) {
  auto size = math::Vector3U{
    a.size.y,
    a.size.x,
    a.size.z
  };
  return Area3U{
    /* u -> { u.y, size.x - u.x - 1, u.z } */
    a.u, std::move(size)
  };
}

inline constexpr auto zyrotated(const Area3U& a) noexcept -> decltype(auto) {
  auto size = math::Vector3U{
    a.size.x,
    a.size.z,
    a.size.y
  };
  return Area3U{
    /* u -> { u.x, size.z - u.z - 1, u.y } */
    a.u, std::move(size)
  };
}

}