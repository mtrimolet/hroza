export module rule;

import std;
import glm;
import stormkit.Core;

import grid;

using namespace stormkit;

export {

struct Rule {
  Grid<std::optional<std::unordered_set<char>>> input;
  Grid<std::optional<char>> output;

  inline constexpr auto operator==(const Rule& other) const noexcept -> bool = default;
};

inline constexpr auto xreflected(const Rule& rule) noexcept -> decltype(auto) {
  return Rule{
    xreflected(rule.input),
    xreflected(rule.output),
  };
}

inline constexpr auto xyrotated(const Rule& rule) noexcept -> decltype(auto) {
  return Rule{
    xyrotated(rule.input),
    xyrotated(rule.output),
  };
}

inline constexpr auto zyrotated(const Rule& rule) noexcept -> decltype(auto) {
  return Rule{
    zyrotated(rule.input),
    zyrotated(rule.output),
  };
}

const auto groups = makeStaticArray<std::function<Rule(const Rule&)>>(
  [](const auto& rule) noexcept { return auto{rule}; },
  [](const auto& rule) noexcept { return xyrotated(rule); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(rule)); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(xyrotated(rule))); },
  [](const auto& rule) noexcept { return xreflected(rule); },
  [](const auto& rule) noexcept { return xyrotated(xreflected(rule)); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(xreflected(rule))); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(xyrotated(xreflected(rule)))); },
);

template <class T>
struct std::hash<std::unordered_set<T>> {
  inline constexpr auto operator()(const std::unordered_set<T>& set) const noexcept -> std::size_t {
    auto seed = std::hash<std::size_t>{}(set.size());
    for (auto i : set) {
      seed ^= std::hash<T>{}(i);
    }
    return seed;
  }
};

template <>
struct std::hash<Rule> {
  inline constexpr auto operator()(const Rule& rule) const noexcept -> std::size_t {
    auto seed = std::hash<math::Vector3U>{}(rule.input.size);
    for (auto i : rule.input.values) {
      seed ^= std::hash<std::optional<std::unordered_set<char>>>{}(i);
    }
    for (auto o : rule.output.values) {
      seed ^= std::hash<std::optional<char>>{}(o);
    }
    return seed;
  }
};

inline constexpr auto symmetries(const Rule& rule) noexcept -> decltype(auto) {
  return groups
    | std::views::transform([&rule](const auto& action) noexcept { return action(rule); })
    | std::ranges::to<std::unordered_set>();
}

inline constexpr auto match(const Grid<>& grid, const math::Vector3U& u, const Rule& rule) noexcept -> decltype(auto) {
  return std::ranges::all_of(
    std::views::zip(rule.input.values, std::views::iota(0) 
      | std::views::transform([&u, &rule](auto i) noexcept { return u + fromIndex(i, rule.input.size); })),
    [&grid](const auto& input) noexcept {
      const auto& [value, v] = input;
      if (value == std::nullopt) return true;
      return std::ranges::find(*value, grid.values.at(toIndex(v, grid.size))) != std::ranges::end(*value);
    }
  );
}

inline constexpr auto changes(const Grid<>& grid, const math::Vector3U& u, const Rule& rule) noexcept -> decltype(auto) {
  return std::views::zip(rule.output.values, std::views::iota(0) 
      | std::views::transform([&u, &rule](auto i) noexcept { return u + fromIndex(i, rule.output.size); }))
    | std::views::filter([&grid](const auto& output) noexcept {
        const auto& [value, v] = output;
        if (value == std::nullopt) return false;
        return *value != grid.values.at(toIndex(v, grid.size));
    })
    | std::views::transform([](auto&& output) noexcept { return std::make_tuple(*std::get<0>(output), std::get<1>(output)); })
    | std::ranges::to<std::vector>();
}

inline constexpr auto apply(Grid<>& grid, const math::Vector3U& u, const Rule& rule) noexcept -> decltype(auto) {
  std::ranges::for_each(changes(grid, u, rule), [&grid](const auto& output) noexcept {
    const auto& [value, v] = output;
    grid.values[toIndex(v, grid.size)] = value;
  });
}

template <std::ranges::sized_range A, std::ranges::sized_range B>
    // requires std::ranges::sized_range<A> and std::ranges::sized_range<B>
inline constexpr auto cartesian_product(A&& a, B&& b) noexcept {
  return std::forward<A>(a) 
    | std::views::transform([&b] (const auto& i) noexcept {
        return std::forward<B>(b)
          | std::views::transform([&i] (const auto& j) noexcept { return std::make_pair(i, j); })
          | std::ranges::to<std::vector>();
    }) 
  | std::views::join
  | std::ranges::to<std::vector>();
}

inline constexpr auto matches(const Grid<>& grid, std::span<const Rule> rules) noexcept -> decltype(auto) {
  const auto g_size = grid.size;
  return rules
    | std::views::transform([&g_size](auto& rule) noexcept {
        return std::views::iota(0u, g_size.z * g_size.y * g_size.x)
          | std::views::transform(bindBack(fromIndex, g_size))
          | std::views::filter(bindBack(inBounds, g_size - rule.input.size))
          | std::views::transform([&rule](auto u) noexcept {
              return std::make_pair(u, rule);
          });
      })
    | std::views::join
    | std::views::filter([&grid](const auto& match) {
        const auto& [u, rule] = match;
        return ::match(grid, u, rule);
    })
    | std::ranges::to<std::vector>();
}

/********* */

inline constexpr auto one(std::span<const Rule> rules, const Grid<>& grid) noexcept -> decltype(auto) {
  auto matches = ::matches(grid, rules);
  if (std::empty(matches)) return auto{grid};

  static auto rg = std::mt19937{std::random_device{}()};
  std::ranges::shuffle(matches, rg);
  const auto& [u, rule] = matches[0];
  auto current_grid = auto{grid};
  apply(current_grid, u, rule);
  return current_grid;
}

struct One {
  std::vector<Rule> rules;
  inline constexpr auto operator()(const Grid<>& grid) const noexcept -> decltype(auto) {
    return one(rules, grid);
  }
};

inline constexpr auto prl(std::span<const Rule> rules, const Grid<>& grid) noexcept -> decltype(auto) {
  auto current_grid = auto{grid};
  std::ranges::for_each(matches(grid, rules), [&current_grid](const auto& match) noexcept {
    const auto& [u, rule] = match;
    apply(current_grid, u, rule);
  });
  return current_grid;
}

struct Prl {
  std::vector<Rule> rules;
  inline constexpr auto operator()(const Grid<>& grid) const noexcept -> decltype(auto) {
    return prl(rules, grid);
  }
};

inline constexpr auto all(std::span<const Rule> rules, const Grid<>& grid) noexcept -> decltype(auto) {
  auto matches = ::matches(grid, rules);
  if (std::empty(matches)) return auto{grid};

  static auto rg = std::mt19937{std::random_device{}()};
  std::ranges::shuffle(matches, rg);
  const auto cleaned = std::ranges::fold_left(matches, std::vector<decltype(matches)::value_type>{}, [](auto a, auto m) noexcept {
    if (std::ranges::find_if(a, [&m](auto i) noexcept { return std::get<0>(i) == std::get<0>(m); }) != std::ranges::end(a))
      return a;
    a.push_back(m);
    return a;
  });
  auto current_grid = auto{grid};
  std::ranges::for_each(cleaned, [&current_grid](const auto& m) noexcept {
    const auto& [u, rule] = m;
    apply(current_grid, u, rule);
  });
  return current_grid;
}

struct All {
  std::vector<Rule> rules;
  inline constexpr auto operator()(const Grid<>& grid) const noexcept -> decltype(auto) {
    return all(rules, grid);
  }
};

}