export module rule;

import std;
import glm;
import stormkit.Core;
import utils;

import grid;

using namespace stormkit;

export {

template <class T>
struct Rule {
  Grid<std::optional<std::unordered_set<T>>> input;
  Grid<std::optional<T>> output;

  inline constexpr auto operator==(const Rule<T>& other) const noexcept -> bool = default;
};

template <class T>
inline constexpr auto xreflected(const Rule<T>& rule) noexcept -> decltype(auto) {
  return Rule<T>{
    xreflected(rule.input),
    xreflected(rule.output),
  };
}

template <class T>
inline constexpr auto xyrotated(const Rule<T>& rule) noexcept -> decltype(auto) {
  return Rule<T>{
    xyrotated(rule.input),
    xyrotated(rule.output),
  };
}

template <class T>
inline constexpr auto zyrotated(const Rule<T>& rule) noexcept -> decltype(auto) {
  return Rule<T>{
    zyrotated(rule.input),
    zyrotated(rule.output),
  };
}

template <class T>
const auto groups = makeStaticArray<std::function<T(const T&)>>(
  [](const auto& rule) noexcept { return auto{rule}; },
  [](const auto& rule) noexcept { return xyrotated(rule); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(rule)); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(xyrotated(rule))); },
  [](const auto& rule) noexcept { return xreflected(rule); },
  [](const auto& rule) noexcept { return xyrotated(xreflected(rule)); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(xreflected(rule))); },
  [](const auto& rule) noexcept { return xyrotated(xyrotated(xyrotated(xreflected(rule)))); },
);

template <class T>
struct std::hash<Rule<T>> {
  inline constexpr auto operator()(const Rule<T>& rule) const noexcept -> std::size_t {
    auto seed = std::hash<math::Vector3U>{}(rule.input.size);
    for (auto i : rule.input.values) {
      seed ^= std::hash<std::optional<std::unordered_set<T>>>{}(i);
    }
    for (auto o : rule.output.values) {
      seed ^= std::hash<std::optional<T>>{}(o);
    }
    return seed;
  }
};

template <class T>
inline constexpr auto symmetries(const Rule<T>& rule) noexcept -> decltype(auto) {
  return groups<Rule<T>>
    | std::views::transform([&rule](const auto& action) noexcept { return action(rule); })
    | std::ranges::to<std::unordered_set>();
}

template <class T>
struct Match {
  math::Vector3U u;
  Rule<T> rule;
};

template <class T>
inline constexpr auto match(const Grid<T>& grid, const Match<T>& match) noexcept -> bool {
  return std::ranges::all_of(
    std::views::zip(match.rule.input.values, std::views::iota(0) 
      | std::views::transform([&match](auto i) noexcept { return match.u + fromIndex(i, match.rule.input.size); })),
    [&grid](const auto& input) noexcept {
      const auto& [value, v] = input;
      return value == std::nullopt
         or std::ranges::find(*value, grid.at(v)) != std::ranges::end(*value);
    }
  );
}

template <class T>
inline constexpr auto changes(const Grid<T>& grid, const Match<T>& match) noexcept -> decltype(auto) {
  return std::views::zip(match.rule.output.values, std::views::iota(0)
      | std::views::transform([&match](auto i) noexcept { return match.u + fromIndex(i, match.rule.output.size); }))
    | std::views::filter([&grid](const auto& output) noexcept {
        const auto& [value, v] = output;
        return  value != std::nullopt
           and *value != grid.at(v);
    })
    | std::views::transform([](auto&& output) noexcept {
        return Change<T>{std::get<1>(output), *std::get<0>(output)};
      })
    | std::ranges::to<std::vector>();
}

template <class T>
inline constexpr auto matches(const Grid<T>& grid, std::span<const Rule<T>> rules) noexcept -> decltype(auto) {
  const auto& g_size = grid.size;
  return rules
    | std::views::transform([&g_size](const auto& rule) noexcept {
        const auto size = g_size - rule.input.size + math::Vector3U{1u, 1u, 1u};
        return std::views::iota(0u, size.z * size.y * size.x)
          | std::views::transform(bindBack(fromIndex, size))
          | std::views::transform([&rule](auto u) noexcept {
              return Match<T>{u, rule};
          });
      })
    | std::views::join
    | std::views::filter(bindFront(::match<T>, grid))
    | std::ranges::to<std::vector>();
        const auto size = g_size - rule.input.size + math::Vector3U{1u, 1u, 1u};
        return std::views::iota(0u, size.z * size.y * size.x)
          | std::views::transform(bindBack(fromIndex, size))
          | std::views::transform([&rule, ri](auto u) noexcept {
              return Match<T>{u, rule, ri};
          });
      })
    | std::views::join
    | std::views::filter(bindFront(::match<T>, grid))
    | std::ranges::to<std::vector>();
}

/********* */

template <class T>
inline constexpr auto one(std::span<const Rule<T>> rules, const Grid<T>& grid) noexcept -> decltype(auto) {
  auto matches = ::matches<T>(grid, rules);
  if (std::ranges::empty(matches)) return std::vector<Change<T>>{};

  static auto rg = std::mt19937{std::random_device{}()};
  std::ranges::shuffle(matches, rg);

  return matches
    | std::views::take(1)
    | std::views::transform(bindFront(::changes<T>, grid))
    | std::views::join 
    | std::ranges::to<std::vector>();
}

template <class T>
struct One {
  std::vector<Rule<T>> rules;
  inline constexpr auto operator()(const Grid<T>& grid) const noexcept -> decltype(auto) {
    return one<T>(rules, grid);
  }
};

template <class T>
inline constexpr auto prl(std::span<const Rule<T>> rules, const Grid<T>& grid) noexcept -> decltype(auto) {
  auto matches = ::matches<T>(grid, rules);
  if (std::ranges::empty(matches)) return std::vector<Change<T>>{};

  return matches
    | std::views::transform(bindFront(::changes<T>, grid)) 
    | std::views::join 
    | std::ranges::to<std::vector>();
}

template <class T>
struct Prl {
  std::vector<Rule<T>> rules;
  inline constexpr auto operator()(const Grid<T>& grid) const noexcept -> decltype(auto) {
    return prl<T>(rules, grid);
  }
};

template <class T>
inline constexpr auto all(std::span<const Rule<T>> rules, const Grid<T>& grid) noexcept -> decltype(auto) {
  auto matches = ::matches<T>(grid, rules);
  if (std::ranges::empty(matches)) return std::vector<Change<T>>{};

  static auto rg = std::mt19937{std::random_device{}()};
  std::ranges::shuffle(matches, rg);
  auto cleaned = std::vector<Match<T>>{};
  std::ranges::for_each(matches, [&cleaned](auto&& m) noexcept {
    if (std::ranges::find(cleaned, m.u, &Match<T>::u) == std::ranges::end(cleaned))
      cleaned.push_back(m);
  });

  return cleaned
    | std::views::transform(bindFront(::changes<T>, grid))
    | std::views::join
    | std::ranges::to<std::vector>();
}

template <class T>
struct All {
  std::vector<Rule<T>> rules;
  inline constexpr auto operator()(const Grid<T>& grid) const noexcept -> decltype(auto) {
    return all<T>(rules, grid);
  }
};

}