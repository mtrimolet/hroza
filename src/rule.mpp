export module rule;

import std;
import glm;
import stormkit.Core;
import utils;

import grid;

using namespace stormkit;
using symbol = char;

constexpr symbol Zsep = ' ';
constexpr symbol Ysep = '/';
constexpr symbol Ignored = '*';

export {

struct Rule {
  Grid<std::optional<std::unordered_set<symbol>>> input;
  Grid<std::optional<symbol>> output;
  double p;

  Rule(Grid<std::optional<std::unordered_set<symbol>>>&& _input, Grid<std::optional<symbol>>&& _output, double _p = 1.0)
    : input{std::move(_input)}, output{std::move(_output)}, p{_p} {}

  inline constexpr auto operator==(const Rule& other) const noexcept -> bool = default;

  static inline constexpr auto parse(
    std::unordered_map<symbol, std::unordered_set<symbol>> unions,
    std::basic_string_view<symbol> _input,
    std::basic_string_view<symbol> _output,
    double p = 1.0
  ) noexcept -> decltype(auto) {
    auto input = Grid<symbol>::parse(Zsep, Ysep, _input);
    auto output = Grid<symbol>::parse(Zsep, Ysep, _output);

    return Rule{
      input
        | std::views::transform([&unions](const symbol& t) noexcept {
            return t == Ignored ? std::nullopt
                 : unions.contains(t) ? std::optional{unions.at(t)}
                 : std::optional{std::unordered_set{t}};
        })
        | std::ranges::to<Grid<std::optional<std::unordered_set<symbol>>>>(input.extents),
      output
        | std::views::transform([](const symbol& t) noexcept {
            return t == Ignored ? std::nullopt : std::optional{t};
        })
        | std::ranges::to<Grid<std::optional<symbol>>>(output.extents),
      p,
    };
  }

  static inline constexpr auto parse(
    std::basic_string_view<symbol> _input,
    std::basic_string_view<symbol> _output,
    double p = 1.0
  ) noexcept -> decltype(auto) {
    return parse({}, _input, _output, p);
  }
};

inline constexpr auto xreflected(const Rule& rule) noexcept -> decltype(auto) {
  return Rule{
    xreflected(rule.input),
    xreflected(rule.output),
    rule.p,
  };
}

inline constexpr auto xyrotated(const Rule& rule) noexcept -> decltype(auto) {
  return Rule{
    xyrotated(rule.input),
    xyrotated(rule.output),
    rule.p,
  };
}

inline constexpr auto zyrotated(const Rule& rule) noexcept -> decltype(auto) {
  return Rule{
    zyrotated(rule.input),
    zyrotated(rule.output),
    rule.p,
  };
}
}

template <class T>
const auto groups = makeStaticArray<std::function<T(const T&)>>(
  [](const T& rule) noexcept { return auto{rule}; },
  [](const T& rule) noexcept { return xyrotated(rule); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(rule)); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(xyrotated(rule))); },
  [](const T& rule) noexcept { return xreflected(rule); },
  [](const T& rule) noexcept { return xyrotated(xreflected(rule)); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(xreflected(rule))); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(xyrotated(xreflected(rule)))); },
);

export {
template <>
struct std::hash<Rule> {
  inline constexpr auto operator()(const Rule& rule) const noexcept -> std::size_t {
    auto seed = std::hash<std::dims<3>>{}(rule.input.extents);
    for (auto v : rule.input) {
      seed ^= std::hash<decltype(v)>{}(v);
    }
    for (auto v : rule.output) {
      seed ^= std::hash<decltype(v)>{}(v);
    }
    return seed;
  }
};

inline constexpr auto symmetries(const Rule& rule, std::string_view subgroup = "") noexcept -> decltype(auto) {
  return groups<Rule>
    | std::views::transform([&rule](const auto& action) noexcept { return action(rule); })
    | std::ranges::to<std::unordered_set>();
}
}
