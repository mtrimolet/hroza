export module rule;

import std;
import glm;
import stormkit.Core;
import utils;

import grid;

using namespace stormkit;

export {

template <class T>
struct Rule {
  Grid<std::optional<std::unordered_set<T>>> input;
  Grid<std::optional<T>> output;
  double p;

  Rule(Grid<std::optional<std::unordered_set<T>>>&& _input, Grid<std::optional<T>>&& _output, double _p = 1.0)
    : input{std::move(_input)}, output{std::move(_output)}, p{_p} {}

  inline constexpr auto operator==(const Rule<T>& other) const noexcept -> bool = default;

  static inline constexpr auto parse(T Zsep, T Ysep, T Ignored, std::basic_string_view<T> _input, std::basic_string_view<T> _output, double p = 1.0) noexcept -> decltype(auto) {
    auto input = Grid<T>::parse(Zsep, Ysep, _input);
    auto output = Grid<T>::parse(Zsep, Ysep, _output);

    return Rule<T>{
      input
        | std::views::transform([Ignored](const T& t) noexcept {
            return t == Ignored ? std::nullopt : std::optional{std::unordered_set{t}};
        })
        | std::ranges::to<Grid<std::optional<std::unordered_set<T>>>>(input.extents),
      output
        | std::views::transform([Ignored](const T& t) noexcept {
            return t == Ignored ? std::nullopt : std::optional{t};
        })
        | std::ranges::to<Grid<std::optional<T>>>(output.extents),
      p,
    };
  }
};

template <class T>
inline constexpr auto xreflected(const Rule<T>& rule) noexcept -> decltype(auto) {
  return Rule<T>{
    xreflected(rule.input),
    xreflected(rule.output),
    rule.p,
  };
}

template <class T>
inline constexpr auto xyrotated(const Rule<T>& rule) noexcept -> decltype(auto) {
  return Rule<T>{
    xyrotated(rule.input),
    xyrotated(rule.output),
    rule.p,
  };
}

template <class T>
inline constexpr auto zyrotated(const Rule<T>& rule) noexcept -> decltype(auto) {
  return Rule<T>{
    zyrotated(rule.input),
    zyrotated(rule.output),
    rule.p,
  };
}
}

template <class T>
const auto groups = makeStaticArray<std::function<T(const T&)>>(
  [](const T& rule) noexcept { return auto{rule}; },
  [](const T& rule) noexcept { return xyrotated(rule); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(rule)); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(xyrotated(rule))); },
  [](const T& rule) noexcept { return xreflected(rule); },
  [](const T& rule) noexcept { return xyrotated(xreflected(rule)); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(xreflected(rule))); },
  [](const T& rule) noexcept { return xyrotated(xyrotated(xyrotated(xreflected(rule)))); },
);

export {
template <class T>
struct std::hash<Rule<T>> {
  inline constexpr auto operator()(const Rule<T>& rule) const noexcept -> std::size_t {
    auto seed = std::hash<std::dims<3>>{}(rule.input.extents);
    for (auto v : rule.input) {
      seed ^= std::hash<std::optional<std::unordered_set<T>>>{}(v);
    }
    for (auto v : rule.output) {
      seed ^= std::hash<std::optional<T>>{}(v);
    }
    return seed;
  }
};

template <class T>
inline constexpr auto symmetries(const Rule<T>& rule) noexcept -> decltype(auto) {
  return groups<Rule<T>>
    | std::views::transform([&rule](const auto& action) noexcept { return action(rule); })
    | std::ranges::to<std::unordered_set>();
}
}

/********* */

export template <class T>
struct Match {
  math::Vector3U u;
  Rule<T> rule;

  inline constexpr auto operator==(const Match<T>& other) const noexcept -> bool {
    return u == other.u and rule == other.rule;
  }
};

template <class T>
inline constexpr auto match(std::mdspan<const T, std::dims<3>> grid, const Match<T>& match) noexcept -> bool {
  return std::ranges::all_of(
    std::views::zip(
      mdiota(toSentinel(match.rule.input.extents)) | std::views::transform([&mu{match.u}](auto u) noexcept { return mu + u; }),
      match.rule.input,
    ),
    [grid{std::move(grid)}](const auto& input) noexcept {
      const auto& [v, value] = input;
      return value == std::nullopt
          or value->contains(grid[v.z, v.y, v.x]);
    }
  );
}

template <class T>
inline constexpr auto changes(std::mdspan<const T, std::dims<3>> grid, const Match<T>& match) noexcept -> decltype(auto) {
  return std::views::zip(
    mdiota(toSentinel(match.rule.output.extents)) | std::views::transform([&mu{match.u}](auto u) noexcept { return mu + u; }),
    match.rule.output,
  )
    | std::views::filter([grid{std::move(grid)}](const auto& output) noexcept {
        const auto& [v, value] = output;
        return  value != std::nullopt
           and *value != grid[v.z, v.y, v.x];
    })
    | std::views::transform([](auto&& output) noexcept {
        return Change<T>{std::get<0>(output), *std::get<1>(output)};
    });
}

template <class T>
struct RulesMatcher {
  std::vector<Rule<T>> rules;
  std::vector<Match<T>> matches;

  RulesMatcher(std::vector<Rule<T>>&& _rules) noexcept
    : rules{std::move(_rules)} {}

  inline constexpr auto newMatches(
    std::mdspan<const T, std::dims<3>> grid,
    std::span<const Change<T>> changes = {}
  ) const noexcept -> decltype(auto) {
    if (std::ranges::empty(changes)) {
      return rules
        | std::views::transform([g_sentinel{toSentinel(grid.extents())}](const Rule<T>& rule) noexcept {
            return mdiota(g_sentinel - toSentinel(rule.input.extents) + math::Vector3U{1u, 1u, 1u})
              | std::views::transform([&rule](auto u) noexcept {
                  return Match<T>{u, rule};
              });
        })
        | std::views::join
        | std::ranges::to<std::vector>();
    }

    return rules
      | std::views::transform([&changes, &g_extents{grid.extents()}](const Rule<T>& rule) noexcept {
          auto rchanges = changes
            | std::views::transform([
                g_sentinel{toSentinel(g_extents)}, 
                ri_sentinel{toSentinel(rule.input.extents)}
              ](const Change<T>& change) noexcept {
                // boundaries
                const auto initial = allMax(
                  change.u + math::Vector3U{1u, 1u, 1u},
                  ri_sentinel
                ) - ri_sentinel;
                const auto sentinel = allMin(
                  g_sentinel - ri_sentinel,
                  change.u
                ) + math::Vector3U{1u, 1u, 1u};
                return mdiota(initial, sentinel);
            })
            | std::views::join
            | std::ranges::to<std::unordered_set>();
          return std::move(rchanges)
            | std::views::transform([&rule](auto u) noexcept {
                return Match<T>{u, rule};
            });
      })
      | std::views::join
      | std::ranges::to<std::vector>();
  }

  inline constexpr auto refreshMatches(
    std::mdspan<const T, std::dims<3>> grid,
    std::span<const Change<T>> changes = {}
  ) noexcept -> decltype(auto) {
    std::erase_if(matches, [grid](auto&& m) noexcept {
      return not ::match(grid, m);
    });

    matches.append_range(newMatches(grid, changes)
      | std::views::filter(bindFront(::match<T>, grid)));

    static auto rg = std::mt19937{std::random_device{}()};
    std::ranges::shuffle(matches, rg);
  }
};

/********* */

struct Foo {
  std::optional<RangeOffset> prev;

  template <std::ranges::input_range History>
  inline constexpr auto bar(History&& history) noexcept -> decltype(auto) {
    const auto now = std::ranges::cend(history);
    const auto since = prev
      .transform([p{std::ranges::cbegin(history)}](auto i) noexcept { 
        return p + i;
      })
      .value_or(now);
    prev = std::ranges::size(history);

    return std::ranges::subrange(since, now);
  }
};

/********* */

export template <class T>
struct One : RulesMatcher<T>, Foo {
  One(std::vector<Rule<T>>&& x) noexcept
    : RulesMatcher<T>{std::move(x)}, Foo{} {}

  inline constexpr auto operator()(const TracedGrid<T>& grid) noexcept -> decltype(auto) {
    const auto changes = Foo::bar(grid.history)
      | std::ranges::to<std::vector>();

    auto mdgrid = std::mdspan{std::ranges::cdata(grid), grid.extents};
    RulesMatcher<T>::refreshMatches(mdgrid, changes);

    return this->matches
      | std::views::filter([](auto&& match) noexcept {
          static auto rg = std::mt19937{std::random_device{}()};
          static auto prob = std::uniform_real_distribution<>(0.0, 1.0);
          return match.rule.p == 1.0 or prob(rg) <= match.rule.p;
      })
      | std::views::take(1)
      | std::views::transform(bindFront(::changes<T>, mdgrid))
      | std::views::join
      | std::ranges::to<std::vector>();
  }
};

export template <class T>
struct Prl : RulesMatcher<T>, Foo {
  Prl(std::vector<Rule<T>>&& x) noexcept
    : RulesMatcher<T>{std::move(x)}, Foo{} {}

  inline constexpr auto operator()(const TracedGrid<T>& grid) noexcept -> decltype(auto) {
    const auto changes = Foo::bar(grid.history)
      | std::ranges::to<std::vector>();

    auto mdgrid = std::mdspan{std::ranges::cdata(grid), grid.extents};
    RulesMatcher<T>::refreshMatches(mdgrid, changes);

    return this->matches
      | std::views::filter([](auto&& match) noexcept {
          static auto rg = std::mt19937{std::random_device{}()};
          static auto prob = std::uniform_real_distribution<>(0.0, 1.0);
          return match.rule.p == 1.0 or prob(rg) <= match.rule.p;
      })
      | std::views::transform(bindFront(::changes<T>, mdgrid))
      | std::views::join
      | std::ranges::to<std::vector>();
  }
};

export template <class T>
struct All : RulesMatcher<T>, Foo {
  All(std::vector<Rule<T>>&& x) noexcept
    : RulesMatcher<T>{std::move(x)}, Foo{} {}

  inline constexpr auto operator()(const TracedGrid<T>& grid) noexcept -> decltype(auto) {
    const auto changes = Foo::bar(grid.history)
      | std::ranges::to<std::vector>();

    auto mdgrid = std::mdspan{std::ranges::cdata(grid), grid.extents};
    RulesMatcher<T>::refreshMatches(mdgrid, changes);

    auto filtered = std::ranges::fold_left(this->matches
      | std::views::filter([](const Match<T>& match) noexcept {
          static auto rg = std::mt19937{std::random_device{}()};
          static auto prob = std::uniform_real_distribution<>(0.0, 1.0);
          return match.rule.p == 1.0 or prob(rg) <= match.rule.p;
      }),
      std::vector<Match<T>>{},
      [](auto&& result, auto&& match) noexcept {
        if (std::ranges::none_of(result, [&match](const auto& visited) noexcept {
          return overlaps(
            visited.u, visited.u + toSentinel(visited.rule.output.extents),
            match.u, match.u + toSentinel(match.rule.input.extents),
          );
        }))
          result.push_back(match);
        return result;
      }
    );

    return std::move(filtered)
      | std::views::transform(bindFront(::changes<T>, mdgrid)) 
      | std::views::join 
      | std::ranges::to<std::vector>();
  }
};