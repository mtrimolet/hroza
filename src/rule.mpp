export module rule;

import std;
import stormkit.Core;
import pugixml;
import symmetry;

using namespace stormkit;

export struct Rule {
public:
  using State = UInt;
  using Symbol = char;
  using Size = std::array<RangeExtent, 3>;
  using Wave = std::vector<Boolean>;

  Size input_size, output_size;

  // size(input) == input_size[0] * input_size[1] * input_size[2];
  std::vector<Wave> input;

  // size(output) == output_size[0] * output_size[1] * output_size[2];
  std::vector<State> output;

  double p;
  // size(binput) == size(input);
  std::vector<State> binput;
  // size(ishifts) == size(oshifts) == size(grid.symbols);
  // size(ishifts[i]) == size(input);
  // size(oshifts[i]) == size(output);
  std::vector<std::vector<math::Vector3I>> ishifts, oshifts;

  Boolean original;

private:

  static auto parseInput(std::string_view block, const std::unordered_map<Symbol, Wave>& waves) -> decltype(auto) {
    const auto get_wave_x = [&waves](const auto& symbol){
      return waves.at(symbol);
    };

    const auto get_wave_yx = [&get_wave_x](const auto& line){
      return line
        | std::views::transform(get_wave_x)
        | std::ranges::to<std::vector>();
    };
  
    const auto get_wave_zyx = [&get_wave_yx](const auto& square){ 
      return square
        | std::views::split('/')
        | std::views::transform(get_wave_yx)
        | std::ranges::to<std::vector>(); 
    };

    return block
      | std::views::split(' ')
      | std::views::transform(get_wave_zyx)
      | std::ranges::to<std::vector>();
  }

  static auto parseOutput(std::string_view block, const std::unordered_map<Symbol, State>& values) -> decltype(auto) {
    const auto get_wave_x = [&values](const auto& symbol){
      return values.at(symbol);
    };

    const auto get_wave_yx = [&get_wave_x](const auto& line){
      return line
        | std::views::transform(get_wave_x)
        | std::ranges::to<std::vector>();
    };
  
    const auto get_wave_zyx = [&get_wave_yx](const auto& square){ 
      return square
        | std::views::split('/')
        | std::views::transform(get_wave_yx)
        | std::ranges::to<std::vector>(); 
    };

    return block
      | std::views::split(' ')
      | std::views::transform(get_wave_zyx)
      | std::ranges::to<std::vector>();
  }

public:
  Rule(
    Size&& _input_size,
    Size&& _output_size,
    std::vector<Wave>&& in,
    std::vector<State>&& out,
    double p,
    auto symbol_count
  )
  : input_size{std::move(_input_size)}, output_size{std::move(_output_size)},
  input{std::move(in)}, output{std::move(out)}, p{p},
  binput{std::views::repeat(0xffu, std::ranges::size(input)) | std::ranges::to<std::vector>()},
  ishifts{std::views::iota(0u, symbol_count) | std::views::transform([this](auto c) {
      return std::views::zip(input, std::views::iota(0u))
        | std::views::filter([c](const auto& inp){ return std::get<0>(inp).at(c); })
        | std::views::transform([this](const auto& inp){
            return math::Vector3I{
              std::get<1>(inp) % std::get<2>(input_size),
              (std::get<1>(inp) / std::get<2>(input_size)) % std::get<1>(input_size),
              (std::get<1>(inp) / (std::get<2>(input_size) * std::get<1>(input_size))) % std::get<0>(input_size),
            };
        })
        | std::ranges::to<std::vector>();
    }) | std::ranges::to<std::vector>()},
  oshifts{std::views::repeat(std::vector<math::Vector3I>{}, symbol_count) | std::ranges::to<std::vector>()} {}

  static auto parse(const pugi::xml_node &xrule,
                    const std::unordered_map<Symbol, Wave>& waves,
                    const std::unordered_map<Symbol, State>& values)
      -> std::expected<Rule, pugi::xml_parse_result> {

    const auto inString = std::string{xrule.attribute("in").as_string()};
    ensures(!std::ranges::empty(inString),
            std::format("missing '{}' attribute in '{}' node [:{}]", "in", "rule", xrule.offset_debug()));
    const auto outString = std::string{xrule.attribute("out").as_string()};
    ensures(!std::ranges::empty(outString),
            std::format("missing '{}' attribute in '{}' node [:{}]", "out", "rule", xrule.offset_debug()));
    // auto finString = xrule.attribute("fin").as_string();
    // auto foutString = xrule.attribute("fout").as_string();
    // auto fileString = xrule.attribute("file").as_string();
    // auto legend = xrule.attribute("legend").as_string();

    auto _in = parseInput(inString, waves);
    auto input_size = Size{
          std::ranges::size(_in),
          std::ranges::size(_in.at(0)),
          std::ranges::size(_in.at(0).at(0))};
    auto in = _in
      | std::views::transform([](auto& square){
          return square
            | std::views::join;
        })
      | std::views::join
      | std::ranges::to<std::vector>();
    
    auto _out = parseOutput(outString, values);
    auto output_size = Size{
          std::ranges::size(_out),
          std::ranges::size(_out.at(0)),
          std::ranges::size(_out.at(0).at(0))};
    auto out = _out
      | std::views::transform([](auto& square){
          return square
            | std::views::join;
        })
      | std::views::join
      | std::ranges::to<std::vector>();

    auto p = xrule.attribute("p").as_double(1.0f);

    return Rule{
        std::move(input_size),
        std::move(output_size),
        std::move(in),
        std::move(out),
        p,
        std::ranges::size(values)
    };
  }

  // auto symmetries(Boolean d2, symmetry::subgroup symmetry) -> decltype(auto) {
  //   if(d2) return symmetry::squareSymmetries(this, Rule::ZRotated, Rule::Reflected, Rule::operator==, symmetry);
  //   return symmetry::cubeSymmetries(this, Rule::ZRotated, Rule:YZRotated, Rule::Reflected, Rule::operator==, symmetry);
  // }
};