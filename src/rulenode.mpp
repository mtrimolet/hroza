export module rulenode;

import std;
import glm;
import stormkit.Core;
import utils;

import grid;
import rule;

using namespace stormkit;
using symbol = char;
using grid_view = std::mdspan<const symbol, std::dims<3>>;

export
struct Match {
  math::Vector3U u;
  Rule rule;
};

inline constexpr auto match(grid_view grid, const Match& match) noexcept -> bool {
  return std::ranges::all_of(
    std::views::zip(
      mdiota(match.rule.input.extents) | std::views::transform([&mu{match.u}](auto u) noexcept { return mu + u; }),
      match.rule.input,
    ),
    [grid{std::move(grid)}](const auto& input) noexcept {
      const auto& [v, value] = input;
      return value == std::nullopt
          or value->contains(grid[v.z, v.y, v.x]);
    }
  );
}

inline constexpr auto changes(grid_view grid, const Match& match) noexcept -> decltype(auto) {
  return std::views::zip(
    mdiota(match.rule.output.extents) | std::views::transform([&mu{match.u}](auto u) noexcept { return mu + u; }),
    match.rule.output,
  )
    | std::views::filter([grid{std::move(grid)}](const auto& output) noexcept {
        const auto& [v, value] = output;
        return  value != std::nullopt
           and *value != grid[v.z, v.y, v.x];
    })
    | std::views::transform([](auto&& output) noexcept {
        return Change<symbol>{std::get<0>(output), *std::get<1>(output)};
    });
}

struct RulesMatcher {
  std::vector<Rule> rules;
  std::vector<Match> matches;

  RulesMatcher(std::vector<Rule>&& _rules) noexcept
    : rules{std::move(_rules)} {}

  inline constexpr auto newMatches(
    grid_view grid,
    std::span<const Change<symbol>> changes = {}
  ) const noexcept -> decltype(auto) {
    if (std::ranges::empty(changes)) {
      return rules
        | std::views::transform([g_sentinel{toSentinel(grid.extents())}](const Rule& rule) noexcept {
            const auto ri_sentinel = toSentinel(rule.input.extents);
            const auto sentinel = g_sentinel - (ri_sentinel - math::Vector3U{1u, 1u, 1u});
            return mdiota({sentinel})
              | std::views::transform([&rule](auto u) noexcept {
                  return Match{u, rule};
              });
        })
        | std::views::join
        | std::ranges::to<std::vector>();
    }

    return rules
      | std::views::transform([&changes, &g_extents{grid.extents()}](const Rule& rule) noexcept {
          auto rchanges = changes
            | std::views::transform([
                g_sentinel{toSentinel(g_extents)}, 
                ri_sentinel{toSentinel(rule.input.extents)}
              ](const Change<symbol>& change) noexcept {
                // boundaries
                const auto bounded_zone = intersect(
                  Area3U{ri_sentinel} + change.u,
                  {ri_sentinel - math::Vector3U{1u, 1u, 1u}, g_sentinel}
                ) - (ri_sentinel - math::Vector3U{1u, 1u, 1u});
                return mdiota(bounded_zone);
            })
            | std::views::join
            | std::ranges::to<std::unordered_set>();
          return std::move(rchanges)
            | std::views::transform([&rule](auto u) noexcept {
                return Match{u, rule};
            });
      })
      | std::views::join
      | std::ranges::to<std::vector>();
  }

  inline constexpr auto refreshMatches(
    grid_view grid,
    std::span<const Change<symbol>> changes = {}
  ) noexcept -> decltype(auto) {
    matches.append_range(newMatches(grid, changes)
      | std::views::filter(bindFront(::match, grid)));
  }
};

/********* */

struct Foo {
  std::optional<RangeOffset> prev;

  template <std::ranges::input_range History>
  inline constexpr auto bar(History&& history) noexcept -> decltype(auto) {
    const auto now = std::ranges::cend(history);
    const auto since = prev
      .transform([p{std::ranges::cbegin(history)}](auto i) noexcept { 
        return p + i;
      })
      .value_or(now);
    prev = std::ranges::size(history);

    return std::ranges::subrange(since, now);
  }
};

/********* */

export
struct One : RulesMatcher, Foo {
  One(std::vector<Rule>&& x) noexcept
    : RulesMatcher{std::move(x)}, Foo{} {}

  inline constexpr auto operator()(const TracedGrid<symbol>& grid) noexcept -> decltype(auto) {
    const auto changes = Foo::bar(grid.history)
      | std::ranges::to<std::vector>();

    auto mdgrid = std::mdspan{std::ranges::cdata(grid), grid.extents};
    std::erase_if(this->matches, [mdgrid](auto&& m) noexcept {
      return not ::match(mdgrid, m);
    });
    RulesMatcher::refreshMatches(mdgrid, changes);

    static auto rg = std::mt19937{std::random_device{}()};
    std::ranges::shuffle(this->matches, rg);

    return this->matches
      | std::views::take(1)
      | std::views::transform(bindFront(::changes, mdgrid))
      | std::views::join
      | std::ranges::to<std::vector>();
  }
};

export
struct Prl : RulesMatcher, Foo {
  Prl(std::vector<Rule>&& x) noexcept
    : RulesMatcher{std::move(x)}, Foo{} {}

  inline constexpr auto operator()(const TracedGrid<symbol>& grid) noexcept -> decltype(auto) {
    const auto changes = Foo::bar(grid.history)
      | std::ranges::to<std::vector>();

    auto mdgrid = std::mdspan{std::ranges::cdata(grid), grid.extents};
    std::erase_if(this->matches, [mdgrid](auto&& m) noexcept {
      return not ::match(mdgrid, m);
    });
    RulesMatcher::refreshMatches(mdgrid, changes);

    return this->matches
      | std::views::filter([](auto&& match) noexcept {
          static auto rg = std::mt19937{std::random_device{}()};
          static auto prob = std::uniform_real_distribution<>(0.0, 1.0);
          return match.rule.p == 1.0 or prob(rg) <= match.rule.p;
      })
      | std::views::transform(bindFront(::changes, mdgrid))
      | std::views::join
      | std::ranges::to<std::vector>();
  }
};

export
struct All : RulesMatcher, Foo {
  All(std::vector<Rule>&& x) noexcept
    : RulesMatcher{std::move(x)}, Foo{} {}

  inline constexpr auto operator()(const TracedGrid<symbol>& grid) noexcept -> decltype(auto) {
    const auto changes = Foo::bar(grid.history)
      | std::ranges::to<std::vector>();

    auto mdgrid = std::mdspan{std::ranges::cdata(grid), grid.extents};
    std::erase_if(this->matches, [mdgrid](auto&& m) noexcept {
      return not ::match(mdgrid, m);
    });
    RulesMatcher::refreshMatches(mdgrid, changes);

    static auto rg = std::mt19937{std::random_device{}()};

    // if potentials
    // else
    std::ranges::shuffle(this->matches, rg);

    auto filtered = std::ranges::fold_left(
      this->matches,
      std::vector<Match>{},
      [](auto&& result, auto&& match) noexcept {
        if (std::ranges::none_of(
          result,
          [&match](const auto& visited) noexcept {
            const auto overlap = intersect(
              Area3U{toSentinel(visited.rule.output.extents)} + visited.u,
              Area3U{toSentinel(match.rule.output.extents)} + match.u
            );
            return std::ranges::any_of(
              mdiota(overlap),
              [](auto&& p) noexcept {
                const auto& [v, m] = p;
                return v and m and *v != *m;
              },
              [&visited, &match](auto&& u) noexcept {
                return std::make_tuple(
                  visited.rule.output.at(u - visited.u),
                  match.rule.output.at(u - match.u)
                );
              }
            );
          }
        ))
          result.push_back(match);
        return result;
      }
    );

    return std::move(filtered)
      | std::views::transform(bindFront(::changes, mdgrid)) 
      | std::views::join 
      | std::ranges::to<std::vector>();
  }
};