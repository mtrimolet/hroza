export module utils;

import std;
import ranges;
import glm;
import stormkit.Core;

using namespace stormkit;

export {

// from: https://stackoverflow.com/a/13370695
template <typename ReturnType, typename... Args>
std::function<ReturnType (Args...)> memoize(std::function<ReturnType (Args...)> func) {
  std::unordered_map<std::tuple<Args...>, ReturnType> cache;
  return ([=](Args... args) mutable {
          std::tuple<Args...> t(args...);
          if (cache.find(t) == cache.end())
             cache[t] = func(args...);
          return cache[t];
  });
}

template <>
struct std::hash<glm::vec<3, unsigned int, glm::packed_highp>> {
  inline constexpr auto operator()(glm::vec<3, unsigned int, glm::packed_highp> u) const noexcept -> std::size_t {
    return std::hash<UInt>{}(u.x) ^ std::hash<UInt>{}(u.y) ^ std::hash<UInt>{}(u.z);
  }
};

template <class T>
struct std::hash<std::unordered_set<T>> {
  inline constexpr auto operator()(const std::unordered_set<T>& set) const noexcept -> std::size_t {
    auto seed = std::hash<std::size_t>{}(set.size());
    for (auto i : set) {
      seed ^= std::hash<T>{}(i);
    }
    return seed;
  }
};

template <class T>
struct std::hash<std::vector<T>> {
  inline constexpr auto operator()(const std::vector<T>& vec) const noexcept -> std::size_t {
    auto seed = std::hash<std::size_t>{}(vec.size());
    for (auto i : vec) {
      seed ^= std::hash<T>{}(i);
    }
    return seed;
  }
};

template <class... T>
struct std::hash<std::tuple<T...>> {
  inline constexpr auto operator()(const std::tuple<T...>& tuple) const noexcept -> std::size_t {
    return std::hash<std::size_t>{}(std::tuple_size_v<std::tuple<T...>>)
      ^ (std::hash<T>{}(tuple) ^ ...);
  }
};

template <std::ranges::sized_range A, std::ranges::sized_range B>
inline constexpr auto cartesian_product(A&& a, B&& b) noexcept -> decltype(auto) {
  return std::forward<A>(a) 
    | std::views::transform([&b] (const auto& i) noexcept {
        return std::forward<B>(b)
          | std::views::transform([&i] (const auto& j) noexcept { return std::make_pair(i, j); })
          | std::ranges::to<std::vector>();
    }) 
  | std::views::join
  | std::ranges::to<std::vector>();
}

template <std::ranges::sized_range A>
inline constexpr auto chunk(A&& a, RangeExtent size) noexcept -> decltype(auto) {
  return std::views::iota(0u, std::ranges::size(a))
    | std::views::stride(size)
    | std::views::transform([&a, size](auto i) noexcept {
        return std::ranges::subrange(
          std::ranges::begin(a) + i,
          std::ranges::begin(a) + i + size,
        );
    });
}
}