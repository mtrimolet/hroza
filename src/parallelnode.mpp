export module parallelnode;

import std;
import glm;
import stormkit.Core;
import pugixml;
import grid;
import rule;
import rulenode;
import symmetry;
import utils;

using namespace stormkit;
using namespace std::literals;

export struct ParallelNode : RuleNode {

  static constexpr auto name = "prl"s;

  ParallelNode(auto&& grid_size, auto&& rules, auto steps) noexcept
      : RuleNode{grid_size, rules, steps} {};

  inline constexpr auto reset() -> void {
    counter = 0;
  }

  static inline constexpr auto parse(const pugi::xml_node& xprl, const Grid& grid, auto&& parentSymmetry) noexcept -> ParallelNode {

    auto xrules = xprl.children("rule") | std::ranges::to<std::vector>();
    if (std::ranges::empty(xrules))
      xrules.push_back(xprl);

    auto rules = xrules
      | std::views::transform([&grid, &parentSymmetry](auto&& xrule) constexpr {
          auto rule = Rule::parse(xrule, grid.waves, grid.values);

          const auto symmetry = std::string_view{xrule.attribute("symmetry").as_string()};
          if (not std::empty(symmetry)) ensures(
            symmetry::isSymmetry(std::get<0>(grid.size) == 1, symmetry),
            std::format("unknown symmetry '{}' [:{}]", symmetry, xrule.offset_debug()));
          
          return rule.symmetries(std::get<0>(grid.size) == 1, std::empty(symmetry) ? parentSymmetry : symmetry);
        })
      | std::views::join
      | std::ranges::to<std::vector>();

    return ParallelNode{grid.size, rules, xprl.attribute("steps").as_uint(0u)};
  }

  static inline constexpr auto apply(Grid& grid, const Rule& rule, const math::Vector3I& u) 
      noexcept -> decltype(auto) {
    return std::views::zip(rule.output, std::views::iota(0u)
        | std::views::transform([&rule, &u](auto i) constexpr { return u + fromIndex(i, rule.output_size); }))
      | std::views::filter([&rule, &grid](const auto& v) constexpr {
          const auto& [newState, s] = v;
          return newState != std::nullopt and newState.value() != grid.at(s);
      })
      | std::views::transform([&grid](const auto v) constexpr {
          const auto& [newState, s] = v;
          grid[s] = newState.value();
          return s;
      })
      | std::ranges::to<std::unordered_set>();
  }

  inline constexpr auto execute(Grid& grid, std::vector<math::Vector3I>& changes, auto& rg)
      noexcept -> bool {
    if (steps > 0 and counter >= steps) return false;

    std::ranges::for_each(loadMatches(grid, changes, rg), [this, &grid](const auto& m) constexpr {
      matchMask[std::get<0>(m)][toIndex(std::get<1>(m), grid.size)] = true;
      matches.push_back(m);
    });

    for (const auto& [r, u] : matches) {
      changes.insert_range(
        std::ranges::end(changes),
        apply(grid, rules.at(r), u));
    }

    matches.clear();
    counter++;
    return true;
  }
};
